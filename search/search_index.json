{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"PolarRoute-Server A web server to manage requests for meshes and routes generated using the PolarRoute and MeshiPhi libraries, implemented using Django , Celery and Django REST framework . It currently takes vessel meshes created using MeshiPhi and serves requests for routes, which are calculated using PolarRoute. Setup/installation PolarRouteServer can be installed from GitHub using pip . Inside a virtual environment (e.g. venv, conda, etc.) run pip install git+https://github.com/bas-amop/PolarRoute-server To install a specific version append the tag, e.g. pip intall git+https://github.com/bas-amop/PolarRoute-server@v0.1.6 Alternatively, clone this repository with git and install from source with pip install -e . Quickstart using docker compose (recommended) Use docker compose for development deployment to orchestrate celery and rabbitmq alongside the django development server. Clone this repository and run docker compose up to build and start the services. Note : In development, meshes are not automatically ingested into the database. Follow these steps to add a mesh to the database. Make a local directory structure with mkdir -p data/mesh and copy a vessel mesh file from MeshiPhi into ./data/mesh , which is bind-mounted into the app container. Run docker compose exec app /bin/bash to open a shell inside the running app container. Run django-admin insert_mesh /usr/src/app/data/mesh/<MESH FILENAME> to insert the mesh into the database manually. Test that the app is working using the demo tool (see Documentation ). The URL of the service should be localhost:8000 . The django development server supports hot reloading and the source code is bind-mounted into the container, so changes should be reflected in the running app. Any changes to polarrouteserver.route_api.models.py will necessitate a migration to the database. To create and run migrations, run: docker compose exec app django-admin makemigrations docker compose exec app django-admin migrate Optionally, Swagger can be used to serve an API schema. This is not started by default, but can be enabled by started docker compose with the --profile swagger option, e.g. docker compose --profile swagger up -d - the swagger UI will be served at localhost:80/swagger . Using this documentation Most of these docs are primarily aimed at developers of the package ( Development ) or administrators who want to deploy a copy of the server ( Deployment ). If you are a user/web developer who would like to request routes from PolarRoute server you should check out the Requesting Routes page and the API Reference .","title":"Home"},{"location":"#polarroute-server","text":"A web server to manage requests for meshes and routes generated using the PolarRoute and MeshiPhi libraries, implemented using Django , Celery and Django REST framework . It currently takes vessel meshes created using MeshiPhi and serves requests for routes, which are calculated using PolarRoute.","title":"PolarRoute-Server"},{"location":"#setupinstallation","text":"PolarRouteServer can be installed from GitHub using pip . Inside a virtual environment (e.g. venv, conda, etc.) run pip install git+https://github.com/bas-amop/PolarRoute-server To install a specific version append the tag, e.g. pip intall git+https://github.com/bas-amop/PolarRoute-server@v0.1.6 Alternatively, clone this repository with git and install from source with pip install -e .","title":"Setup/installation"},{"location":"#quickstart-using-docker-compose-recommended","text":"Use docker compose for development deployment to orchestrate celery and rabbitmq alongside the django development server. Clone this repository and run docker compose up to build and start the services. Note : In development, meshes are not automatically ingested into the database. Follow these steps to add a mesh to the database. Make a local directory structure with mkdir -p data/mesh and copy a vessel mesh file from MeshiPhi into ./data/mesh , which is bind-mounted into the app container. Run docker compose exec app /bin/bash to open a shell inside the running app container. Run django-admin insert_mesh /usr/src/app/data/mesh/<MESH FILENAME> to insert the mesh into the database manually. Test that the app is working using the demo tool (see Documentation ). The URL of the service should be localhost:8000 . The django development server supports hot reloading and the source code is bind-mounted into the container, so changes should be reflected in the running app. Any changes to polarrouteserver.route_api.models.py will necessitate a migration to the database. To create and run migrations, run: docker compose exec app django-admin makemigrations docker compose exec app django-admin migrate Optionally, Swagger can be used to serve an API schema. This is not started by default, but can be enabled by started docker compose with the --profile swagger option, e.g. docker compose --profile swagger up -d - the swagger UI will be served at localhost:80/swagger .","title":"Quickstart using docker compose (recommended)"},{"location":"#using-this-documentation","text":"Most of these docs are primarily aimed at developers of the package ( Development ) or administrators who want to deploy a copy of the server ( Deployment ). If you are a user/web developer who would like to request routes from PolarRoute server you should check out the Requesting Routes page and the API Reference .","title":"Using this documentation"},{"location":"api/","text":"SwaggerUIBundle({ url: 'apischema.yml', dom_id: '#swagger-ui-1', })","title":"API Reference"},{"location":"configuration/","text":"Configuration Configuration of PolarRouteServer works with environment variables. You can either set these directly or from a .env file. An example .env file is included in the repo as env.example . Environment variables used directly by the Django site are prefixed wit POLARROUTE_ and those which configure Celery are prefixed with CELERY_ . Mesh settings POLARROUTE_MESH_DIR - absolute path to directory where mesh files will be made available (this location is periodically checked in production and new files ingested into the database based on the metadata file). A warning is logged in production if this is not set. POLARROUTE_MESH_METADATA_DIR - as above, absolute path to directory where mesh metadata files will be made available. If this is not set, the value of POLARROUTE_MESH_DIR is used and a warning to this effect is logged. Django settings The following are inherited from Django and more information can be found on their effects via the Django docs . POLARROUTE_DEBUG - enables Django debug options, must be False in production (default: False ) POLARROUTE_SECRET_KEY - secret hash used for cookie signing etc. Must be set in production. A random key is generated if one is not set. DJANGO_SETTINGS_MODULE - sets the settings envrionment. Options: polarrouteserver.settings.{production,development,test} (Default: polarrroutesserver.settings.production ) POLARROUTE_ALLOWED_HOSTS - comma-separated (no spaces) list of IP addresses or hostnames allowed for the server. POLARROUTE_CORS_ALLOWED_ORIGINS - comma-separated (no spaces) list of IP addresses allowed for Cross Origin Site Requests. (See django-cors-headers on PyPI for more.) CELERY_BROKER_URL - URL for rabbitMQ message broker used by celery. (Default: amqp://guest:guest@localhost ) POLARROUTE_LOG_LEVEL - sets the logging level from standard log level options: INFO, DEBUG, ERROR, WARNING etc. (Default: INFO ) POLARROUTE_LOG_DIR - sets the output directory for logs. By default only used in production settings environment. POLARROUTE_STATIC_ROOT - the path to directory used for static file serving in production, e.g. \"/var/www/example.com/static/\" (Default: None ) Note this is only used for the admin panel in this application. Database settings POLARROUTE_DB_NAME - postgres database name (default: polarroute ) POLARROUTE_DB_USER - postgres database user (default: polarroute ) POLARROUTE_DB_PASSWORD - postgres database password (default: polarroute ) POLARROUTE_DB_HOST - postgres database host (default: 127.0.0.1 ) POLARROUTE_DB_PORT - postgres database port (default: 5432 )","title":"Configuration"},{"location":"configuration/#configuration","text":"Configuration of PolarRouteServer works with environment variables. You can either set these directly or from a .env file. An example .env file is included in the repo as env.example . Environment variables used directly by the Django site are prefixed wit POLARROUTE_ and those which configure Celery are prefixed with CELERY_ .","title":"Configuration"},{"location":"configuration/#mesh-settings","text":"POLARROUTE_MESH_DIR - absolute path to directory where mesh files will be made available (this location is periodically checked in production and new files ingested into the database based on the metadata file). A warning is logged in production if this is not set. POLARROUTE_MESH_METADATA_DIR - as above, absolute path to directory where mesh metadata files will be made available. If this is not set, the value of POLARROUTE_MESH_DIR is used and a warning to this effect is logged.","title":"Mesh settings"},{"location":"configuration/#django-settings","text":"The following are inherited from Django and more information can be found on their effects via the Django docs . POLARROUTE_DEBUG - enables Django debug options, must be False in production (default: False ) POLARROUTE_SECRET_KEY - secret hash used for cookie signing etc. Must be set in production. A random key is generated if one is not set. DJANGO_SETTINGS_MODULE - sets the settings envrionment. Options: polarrouteserver.settings.{production,development,test} (Default: polarrroutesserver.settings.production ) POLARROUTE_ALLOWED_HOSTS - comma-separated (no spaces) list of IP addresses or hostnames allowed for the server. POLARROUTE_CORS_ALLOWED_ORIGINS - comma-separated (no spaces) list of IP addresses allowed for Cross Origin Site Requests. (See django-cors-headers on PyPI for more.) CELERY_BROKER_URL - URL for rabbitMQ message broker used by celery. (Default: amqp://guest:guest@localhost ) POLARROUTE_LOG_LEVEL - sets the logging level from standard log level options: INFO, DEBUG, ERROR, WARNING etc. (Default: INFO ) POLARROUTE_LOG_DIR - sets the output directory for logs. By default only used in production settings environment. POLARROUTE_STATIC_ROOT - the path to directory used for static file serving in production, e.g. \"/var/www/example.com/static/\" (Default: None ) Note this is only used for the admin panel in this application.","title":"Django settings"},{"location":"configuration/#database-settings","text":"POLARROUTE_DB_NAME - postgres database name (default: polarroute ) POLARROUTE_DB_USER - postgres database user (default: polarroute ) POLARROUTE_DB_PASSWORD - postgres database password (default: polarroute ) POLARROUTE_DB_HOST - postgres database host (default: 127.0.0.1 ) POLARROUTE_DB_PORT - postgres database port (default: 5432 )","title":"Database settings"},{"location":"deployment/","text":"Deployment For a production deployment, the following are required: WSGI server, e.g. Gunicorn, mod_wsgi (httpd), PostgreSQL database Celery and celery beat servers running, Access to a RabbitMQ server, Configuration Configuration of PolarRouteServer works with environment variables, these are covered in Configuration in detail. It is up to you how you choose to set these environment variables in your deployment. Setting up the database Assuming you have a running PostgreSQL database and that the environment variables are set, particularly all of the database connection settings and DJANGO_SETTINGS_MODULE run: $ django-admin migrate to build the database. Create a superuser in the database Run the following and follow the prompts. $ django-admin createsuperuser Management of a deployment All of the commands used for administration of a Django project are available post-installation via the django-admin command. Note that the envrionment variables used will need to be set in the session which you're running these commands. Note that the same commands can be run by running python manage.py where manage.py is the file contained in the top level of the repository. Of particular interest in production are: $ django-admin makemigrations # create new migrations files based on changes to models $ django-admin migrate # apply new migrations files to alter the database $ django-admin dbshell # open the database's command line interface To see more commands, run django-admin --help . In addition a custom command is available to manually insert new meshes into the database from file: $ django-admin insert_mesh <Mesh file or list of files> insert_mesh takes a filename or list of filepaths containing meshes either as .vessel.json format or gzipped vessel mesh files. Only meshes which are not present in the database will be inserted. Uniqueness is based on the md5 hash of the unzipped vessel mesh file. Configuring a web server PolarRoute-server can be served similarly to any other Django application, see Django docs for more information . Or see the instructions for httpd/mod_wsgi below. Configuring mod_wsgi If you are using mod_wsgi to serve PolarRoute-server under httpd, a typical .conf file may look something like: <VirtualHost *:443> ServerName polarroute.myserver.com DocumentRoot /path/to/my/polarrouteserver/ LogLevel info SSLEngine on SSLCertificateFile /local/certs/myserver.com.pem PassEnv DJANGO_SETTINGS_MODULE PassEnv POLARROUTE_MESH_DIR PassEnv POLARROUTE_MESH_METADATA_DIR PassEnv POLARROUTE_ALLOWED_HOSTS PassEnv POLARROUTE_CORS_ALLOWED_ORIGINS PassEnv POLARROUTE_STATIC_ROOT PassEnv CELERY_BROKER_URL PassEnv CELERYD_CHDIR PassEnv POLARROUTE_DEBUG PassEnv POLARROUTE_LOG_DIR PassEnv POLARROUTE_BASE_DIR PassEnv POLARROUTE_LOG_LEVEL PassEnv POLARROUTE_DB_NAME PassEnv POLARROUTE_DB_USER PassEnv POLARROUTE_DB_PASSWORD PassEnv POLARROUTE_DB_HOST WSGIDaemonProcess polarroute.myserver.com user=wsgi group=wsgi threads=5 python-home=/path/to/my/python/home python-path=/path/to/my/python/path WSGIProcessGroup polarroute.myserver.com WSGIApplicationGroup %{GLOBAL} WSGIScriptAlias / /path/to/my/polarrouteserver//wsgi.py Alias /static /var/www/polarroute.myserver.com/static CustomLog /var/log/httpd/access_log.polarroute.myserver.com combined ErrorLog /var/log/httpd/error_log.polarroute.myserver.com <Location /> Require all granted </Location> </VirtualHost> <Directory \"/path/to/my/polarrouteserver/\"> AllowOverride All Options -Indexes Require all granted WSGIScriptReloading On WSGIProcessGroup polarroute.myserver.com WSGIApplicationGroup %{GLOBAL} </Directory> <Directory /var/www/polarroute.myserver.com/static/> Order allow,deny Allow from all </Directory> Collecting static files PolarRoute-server itself has no static files since it is a headless server, however it does make use of Django's /admin endpoint as a database management dashboard. For this to work, we need to create a static file location, e.g. /var/www/polarroute.{{ hostname }}/static and run the following commands (noting to use the correct path to your static file location): export DJANGO_SETTINGS_MODULE=polarrouteserver.settings.production export POLARROUTE_STATIC_ROOT=/var/www/polarroute.myserver.com/static/ django-admin collecstatic This only needs to be run once. Other recommendations It is also recommended to do the following in a deployment: Add polarrouteserver and celery logs to logrotate - logfiles are written from polarrouteserver and celery to files in POLARROUTE_LOG_DIR , it is prudent to add these to a log rotation utility such as logrotate. Manage Celery, Celerybeat and rabbitmq under systemd.","title":"Deployment"},{"location":"deployment/#deployment","text":"For a production deployment, the following are required: WSGI server, e.g. Gunicorn, mod_wsgi (httpd), PostgreSQL database Celery and celery beat servers running, Access to a RabbitMQ server,","title":"Deployment"},{"location":"deployment/#configuration","text":"Configuration of PolarRouteServer works with environment variables, these are covered in Configuration in detail. It is up to you how you choose to set these environment variables in your deployment.","title":"Configuration"},{"location":"deployment/#setting-up-the-database","text":"Assuming you have a running PostgreSQL database and that the environment variables are set, particularly all of the database connection settings and DJANGO_SETTINGS_MODULE run: $ django-admin migrate to build the database.","title":"Setting up the database"},{"location":"deployment/#create-a-superuser-in-the-database","text":"Run the following and follow the prompts. $ django-admin createsuperuser","title":"Create a superuser in the database"},{"location":"deployment/#management-of-a-deployment","text":"All of the commands used for administration of a Django project are available post-installation via the django-admin command. Note that the envrionment variables used will need to be set in the session which you're running these commands. Note that the same commands can be run by running python manage.py where manage.py is the file contained in the top level of the repository. Of particular interest in production are: $ django-admin makemigrations # create new migrations files based on changes to models $ django-admin migrate # apply new migrations files to alter the database $ django-admin dbshell # open the database's command line interface To see more commands, run django-admin --help . In addition a custom command is available to manually insert new meshes into the database from file: $ django-admin insert_mesh <Mesh file or list of files> insert_mesh takes a filename or list of filepaths containing meshes either as .vessel.json format or gzipped vessel mesh files. Only meshes which are not present in the database will be inserted. Uniqueness is based on the md5 hash of the unzipped vessel mesh file.","title":"Management of a deployment"},{"location":"deployment/#configuring-a-web-server","text":"PolarRoute-server can be served similarly to any other Django application, see Django docs for more information . Or see the instructions for httpd/mod_wsgi below.","title":"Configuring a web server"},{"location":"deployment/#configuring-mod_wsgi","text":"If you are using mod_wsgi to serve PolarRoute-server under httpd, a typical .conf file may look something like: <VirtualHost *:443> ServerName polarroute.myserver.com DocumentRoot /path/to/my/polarrouteserver/ LogLevel info SSLEngine on SSLCertificateFile /local/certs/myserver.com.pem PassEnv DJANGO_SETTINGS_MODULE PassEnv POLARROUTE_MESH_DIR PassEnv POLARROUTE_MESH_METADATA_DIR PassEnv POLARROUTE_ALLOWED_HOSTS PassEnv POLARROUTE_CORS_ALLOWED_ORIGINS PassEnv POLARROUTE_STATIC_ROOT PassEnv CELERY_BROKER_URL PassEnv CELERYD_CHDIR PassEnv POLARROUTE_DEBUG PassEnv POLARROUTE_LOG_DIR PassEnv POLARROUTE_BASE_DIR PassEnv POLARROUTE_LOG_LEVEL PassEnv POLARROUTE_DB_NAME PassEnv POLARROUTE_DB_USER PassEnv POLARROUTE_DB_PASSWORD PassEnv POLARROUTE_DB_HOST WSGIDaemonProcess polarroute.myserver.com user=wsgi group=wsgi threads=5 python-home=/path/to/my/python/home python-path=/path/to/my/python/path WSGIProcessGroup polarroute.myserver.com WSGIApplicationGroup %{GLOBAL} WSGIScriptAlias / /path/to/my/polarrouteserver//wsgi.py Alias /static /var/www/polarroute.myserver.com/static CustomLog /var/log/httpd/access_log.polarroute.myserver.com combined ErrorLog /var/log/httpd/error_log.polarroute.myserver.com <Location /> Require all granted </Location> </VirtualHost> <Directory \"/path/to/my/polarrouteserver/\"> AllowOverride All Options -Indexes Require all granted WSGIScriptReloading On WSGIProcessGroup polarroute.myserver.com WSGIApplicationGroup %{GLOBAL} </Directory> <Directory /var/www/polarroute.myserver.com/static/> Order allow,deny Allow from all </Directory>","title":"Configuring mod_wsgi"},{"location":"deployment/#collecting-static-files","text":"PolarRoute-server itself has no static files since it is a headless server, however it does make use of Django's /admin endpoint as a database management dashboard. For this to work, we need to create a static file location, e.g. /var/www/polarroute.{{ hostname }}/static and run the following commands (noting to use the correct path to your static file location): export DJANGO_SETTINGS_MODULE=polarrouteserver.settings.production export POLARROUTE_STATIC_ROOT=/var/www/polarroute.myserver.com/static/ django-admin collecstatic This only needs to be run once.","title":"Collecting static files"},{"location":"deployment/#other-recommendations","text":"It is also recommended to do the following in a deployment: Add polarrouteserver and celery logs to logrotate - logfiles are written from polarrouteserver and celery to files in POLARROUTE_LOG_DIR , it is prudent to add these to a log rotation utility such as logrotate. Manage Celery, Celerybeat and rabbitmq under systemd.","title":"Other recommendations"},{"location":"development/","text":"Development Depends on: Python >=3.11 docker for running rabbitmq Make Clone the repository and create and activate a python virtual environment of your choice. Inside a virtual environment or machine: pip install -e .[dev] Before first use, create the database by running make migrate To start all of the services needed for the dev deployment run: make serve-dev (which sets the DJANGO_SETTINGS_MODULE environment variable and spins up celery, rabbitmq in a docker container, and the Django development server) For development, also install and use the development tools with pre-commit install A number of helpful development tools are made available through the Makefile , to see a description of each of these commands, run make (with no arguments) from the top-level of this directory. Release/Versioning Version numbers should be used in tagging commits on the main branch and reflected in the pyproject.toml file and should be of the form v0.1.7 using the semantic versioning convention. Building & deploying the documentation Run make build-docs to build the docs to the ./site directory. Then run make deploy-docs to deploy to the gh-pages branch of the repository. You must have write access to the repo. Making changes to the API The API is documented in ./docs/apischema.yml using the OpenAPI 3.0 standard (formerly known as swagger). Any changes to the Web API should be manually reflected in the schema. These can be checked by building the docs and checking the API reference page or serving using swagger ( make start-swagger ).","title":"Development"},{"location":"development/#development","text":"Depends on: Python >=3.11 docker for running rabbitmq Make Clone the repository and create and activate a python virtual environment of your choice. Inside a virtual environment or machine: pip install -e .[dev] Before first use, create the database by running make migrate To start all of the services needed for the dev deployment run: make serve-dev (which sets the DJANGO_SETTINGS_MODULE environment variable and spins up celery, rabbitmq in a docker container, and the Django development server) For development, also install and use the development tools with pre-commit install A number of helpful development tools are made available through the Makefile , to see a description of each of these commands, run make (with no arguments) from the top-level of this directory.","title":"Development"},{"location":"development/#releaseversioning","text":"Version numbers should be used in tagging commits on the main branch and reflected in the pyproject.toml file and should be of the form v0.1.7 using the semantic versioning convention.","title":"Release/Versioning"},{"location":"development/#building-deploying-the-documentation","text":"Run make build-docs to build the docs to the ./site directory. Then run make deploy-docs to deploy to the gh-pages branch of the repository. You must have write access to the repo.","title":"Building &amp; deploying the documentation"},{"location":"development/#making-changes-to-the-api","text":"The API is documented in ./docs/apischema.yml using the OpenAPI 3.0 standard (formerly known as swagger). Any changes to the Web API should be manually reflected in the schema. These can be checked by building the docs and checking the API reference page or serving using swagger ( make start-swagger ).","title":"Making changes to the API"},{"location":"how-polarroute-server-works/","text":"How PolarRoute-server works This page gives an overview of the architecture and approach of the software for developers or administrators of PolarRoute-server. PolarRoute-server architecture As with all Django apps, PolarRoute-server follows a model-view-controller-like architecture ( see Django FAQ for the specifics ) in which a models.py file defines the tables in the database; views.py defines the handling of HTTP requests. Most Django apps also have templates, but since PolarRoute-server is headless, we don't need these. In brief: User requests a route via POST request to the /api/route endpoint, Route calculation is started as a celery job (defined in tasks.py ) and the client is returned a URL from which it can request route status information. Client polls the /api/route/{uuid} endpoint by GET request, status information is returned, and the route as well once it is complete. To calculate a route, PolarRoute requires a mesh that covers the area of the start and end points of the route. Ingesting meshes into the database For the time-being, meshes are calculated separately to PolarRoute-server, either with PolarRoute-pipeline or with MeshiPhi directly. The application takes vessel meshes, with the vessel transformation already applied. Meshes can be ingested into the database manually or automatically. By default, development deployments (using the polarrouteserver/settings/development.py settings) perform no automatic mesh ingestion, and production deployments (using the polarrouteserver/settings/production.py settings) use celery-beat to perform automatic ingestion of meshes every 10 minutes, running the import_new_meshes task ( polarrouteserver/route_api/tasks.py ). Automatically Meshes are found automatically in the directories specified using the POLARROUTE_MESH_DIR & POLARROUTE_MESH_METADATA_DIR environment variables (see Configuration for specific behaviour). Mesh metadata files produced by PolarRoute-pipeline are used to validate newly available meshes, only meshes which are not already in the database (determined using their md5 hash) are ingested. Mesh metadatafiles must be named according to the format upload_metadata_*.yaml.gz to be found. Manually Individual or lists of mesh files can be ingested into the database by running the insert_mesh command using django-admin or python manage.py , e.g. django-admin insert_mesh path/to/my/mesh.vessel.json . insert_mesh can take json files or json.gz files. Route requests and jobs When a route is requested, the select_mesh function is called to determine which mesh to use (described below in Mesh selection ) unless a specific mesh id is requested in the route request. The route_exists function is called for the start and end points and the mesh selected, if there is already an existing route which was successful, this is returned unless the client specifies force_recalculate: true , in which case the route is recalculated. Whether a route is considered to \"exist\" or not depends on a tolerance in the haversine distance of the requested start and end locations compared to routes which have already been calculated. This distance by default is 1 nautical mile (set by the WAYPOINT_DISTANCE_TOLERANCE setting). In other words, if a route is requested where the requested start point is within 1NM of a route already calculated and the same is true of the end point, this route is returned under default conditions. Note that if a newer mesh is available, a new route will be calculated. Because route optimisation jobs can take several minutes, this is done by an asynchronous job queue managed by celery. If the route optimisation fails, the next mesh in priority order is tried if the failure is due to the route being \"inaccessible\" on the mesh. Mesh selection Before a route is calculated, a priority list of meshes is created by polarrouteserver.route_api.utils.select_mesh . It takes all of the meshes that contain the requested start and end coordinates and that were created on the latest date available out of those meshes and returns this list of meshes sorted from smallest to largest total area. Troubleshooting","title":"How PolarRoute-server works"},{"location":"how-polarroute-server-works/#how-polarroute-server-works","text":"This page gives an overview of the architecture and approach of the software for developers or administrators of PolarRoute-server.","title":"How PolarRoute-server works"},{"location":"how-polarroute-server-works/#polarroute-server-architecture","text":"As with all Django apps, PolarRoute-server follows a model-view-controller-like architecture ( see Django FAQ for the specifics ) in which a models.py file defines the tables in the database; views.py defines the handling of HTTP requests. Most Django apps also have templates, but since PolarRoute-server is headless, we don't need these. In brief: User requests a route via POST request to the /api/route endpoint, Route calculation is started as a celery job (defined in tasks.py ) and the client is returned a URL from which it can request route status information. Client polls the /api/route/{uuid} endpoint by GET request, status information is returned, and the route as well once it is complete. To calculate a route, PolarRoute requires a mesh that covers the area of the start and end points of the route.","title":"PolarRoute-server architecture"},{"location":"how-polarroute-server-works/#ingesting-meshes-into-the-database","text":"For the time-being, meshes are calculated separately to PolarRoute-server, either with PolarRoute-pipeline or with MeshiPhi directly. The application takes vessel meshes, with the vessel transformation already applied. Meshes can be ingested into the database manually or automatically. By default, development deployments (using the polarrouteserver/settings/development.py settings) perform no automatic mesh ingestion, and production deployments (using the polarrouteserver/settings/production.py settings) use celery-beat to perform automatic ingestion of meshes every 10 minutes, running the import_new_meshes task ( polarrouteserver/route_api/tasks.py ).","title":"Ingesting meshes into the database"},{"location":"how-polarroute-server-works/#automatically","text":"Meshes are found automatically in the directories specified using the POLARROUTE_MESH_DIR & POLARROUTE_MESH_METADATA_DIR environment variables (see Configuration for specific behaviour). Mesh metadata files produced by PolarRoute-pipeline are used to validate newly available meshes, only meshes which are not already in the database (determined using their md5 hash) are ingested. Mesh metadatafiles must be named according to the format upload_metadata_*.yaml.gz to be found.","title":"Automatically"},{"location":"how-polarroute-server-works/#manually","text":"Individual or lists of mesh files can be ingested into the database by running the insert_mesh command using django-admin or python manage.py , e.g. django-admin insert_mesh path/to/my/mesh.vessel.json . insert_mesh can take json files or json.gz files.","title":"Manually"},{"location":"how-polarroute-server-works/#route-requests-and-jobs","text":"When a route is requested, the select_mesh function is called to determine which mesh to use (described below in Mesh selection ) unless a specific mesh id is requested in the route request. The route_exists function is called for the start and end points and the mesh selected, if there is already an existing route which was successful, this is returned unless the client specifies force_recalculate: true , in which case the route is recalculated. Whether a route is considered to \"exist\" or not depends on a tolerance in the haversine distance of the requested start and end locations compared to routes which have already been calculated. This distance by default is 1 nautical mile (set by the WAYPOINT_DISTANCE_TOLERANCE setting). In other words, if a route is requested where the requested start point is within 1NM of a route already calculated and the same is true of the end point, this route is returned under default conditions. Note that if a newer mesh is available, a new route will be calculated. Because route optimisation jobs can take several minutes, this is done by an asynchronous job queue managed by celery. If the route optimisation fails, the next mesh in priority order is tried if the failure is due to the route being \"inaccessible\" on the mesh.","title":"Route requests and jobs"},{"location":"how-polarroute-server-works/#mesh-selection","text":"Before a route is calculated, a priority list of meshes is created by polarrouteserver.route_api.utils.select_mesh . It takes all of the meshes that contain the requested start and end coordinates and that were created on the latest date available out of those meshes and returns this list of meshes sorted from smallest to largest total area.","title":"Mesh selection"},{"location":"how-polarroute-server-works/#troubleshooting","text":"","title":"Troubleshooting"},{"location":"requesting-routes/","text":"Requesting Routes Using the in-built demo utility (simplest) A demo script is available in this repo ( polarrouteserver/demo.py ) to be used as a utility for making route requests. To obtain, either: Clone this whole repo Download the file from its GitHub page here: https://github.com/bas-amop/PolarRoute-server/blob/main/demo.py This can be done with wget by running: wget https://raw.githubusercontent.com/bas-amop/PolarRoute-server/refs/heads/main/polarrouteserver/demo.py To run, you'll just need python ~3.11 installed. Earlier versions of python may work, but are untested. Usage Help for the utility can be printed out by running python demo.py --help . Alternatively, if you have the package installed, a command named request_route is made available. $ request_route --help # OR $ python demo.py --help usage: demo.py [-h] [-u URL] -s [START] -e [END] [-d [DELAY]] [-f] [-o [OUTPUT]] Requests a route from polarRouteServer, repeating the request for status until the route is available. Specify start and end points by coordinates or from one of the standard locations: ['bird', 'falklands', 'halley', 'rothera', 'kep', 'signy', 'nyalesund', 'harwich', 'rosyth'] options: -h, --help show this help message and exit -u URL, --url URL Base URL to send request to. -s [START], --start [START] Start location either as the name of a standard location or latitude,longitude separated by a comma, e.g. -56.7,-65.01 -e [END], --end [END] End location either as the name of a standard location or latitude,longitude separated by a comma, e.g. -56.7,-65.01 -d [DELAY], --delay [DELAY] (integer) number of seconds to delay between status calls. -f, --force Force polarRouteServer to recalculate the route even if it is already available. -o [OUTPUT], --output [OUTPUT] File path to write out route to. (Default: None and print to stdout) So to request a route from Falklands to Rothera, for example: python demo.py --url example-polar-route-server.com -s falklands -e rothera --delay 120 --output demo_output.json This will request the route from the server running at example-polar-route-server.com , and initiate a route calculation if one is not already available. The utility will then request the route's status every 120 seconds. The HTTP response from each request will be printed to stdout. Once the route is available it will be returned, or if 10 attempts to get the route have passed, the utility will stop. By making HTTP requests For details on the API, see the API reference page . To request a route, make a POST request to the /api/route endpoint, for example the following using CURL curl --header \"Content-Type: application/json\" \\ --request POST \\ --data '{\"start_lat\":\"43.21\",\"start_lon\":\"43.21\", \"end_lat\":\"43.21\",\"end_lon\":\"43.21\"}' \\ http://localhost:8000/api/route This will return a status-url where you can request the status of the route calculation using a GET request, when the route is ready the same URL will return the route in the response.","title":"Requesting Routes"},{"location":"requesting-routes/#requesting-routes","text":"","title":"Requesting Routes"},{"location":"requesting-routes/#using-the-in-built-demo-utility-simplest","text":"A demo script is available in this repo ( polarrouteserver/demo.py ) to be used as a utility for making route requests. To obtain, either: Clone this whole repo Download the file from its GitHub page here: https://github.com/bas-amop/PolarRoute-server/blob/main/demo.py This can be done with wget by running: wget https://raw.githubusercontent.com/bas-amop/PolarRoute-server/refs/heads/main/polarrouteserver/demo.py To run, you'll just need python ~3.11 installed. Earlier versions of python may work, but are untested.","title":"Using the in-built demo utility (simplest)"},{"location":"requesting-routes/#usage","text":"Help for the utility can be printed out by running python demo.py --help . Alternatively, if you have the package installed, a command named request_route is made available. $ request_route --help # OR $ python demo.py --help usage: demo.py [-h] [-u URL] -s [START] -e [END] [-d [DELAY]] [-f] [-o [OUTPUT]] Requests a route from polarRouteServer, repeating the request for status until the route is available. Specify start and end points by coordinates or from one of the standard locations: ['bird', 'falklands', 'halley', 'rothera', 'kep', 'signy', 'nyalesund', 'harwich', 'rosyth'] options: -h, --help show this help message and exit -u URL, --url URL Base URL to send request to. -s [START], --start [START] Start location either as the name of a standard location or latitude,longitude separated by a comma, e.g. -56.7,-65.01 -e [END], --end [END] End location either as the name of a standard location or latitude,longitude separated by a comma, e.g. -56.7,-65.01 -d [DELAY], --delay [DELAY] (integer) number of seconds to delay between status calls. -f, --force Force polarRouteServer to recalculate the route even if it is already available. -o [OUTPUT], --output [OUTPUT] File path to write out route to. (Default: None and print to stdout) So to request a route from Falklands to Rothera, for example: python demo.py --url example-polar-route-server.com -s falklands -e rothera --delay 120 --output demo_output.json This will request the route from the server running at example-polar-route-server.com , and initiate a route calculation if one is not already available. The utility will then request the route's status every 120 seconds. The HTTP response from each request will be printed to stdout. Once the route is available it will be returned, or if 10 attempts to get the route have passed, the utility will stop.","title":"Usage"},{"location":"requesting-routes/#by-making-http-requests","text":"For details on the API, see the API reference page . To request a route, make a POST request to the /api/route endpoint, for example the following using CURL curl --header \"Content-Type: application/json\" \\ --request POST \\ --data '{\"start_lat\":\"43.21\",\"start_lon\":\"43.21\", \"end_lat\":\"43.21\",\"end_lon\":\"43.21\"}' \\ http://localhost:8000/api/route This will return a status-url where you can request the status of the route calculation using a GET request, when the route is ready the same URL will return the route in the response.","title":"By making HTTP requests"},{"location":"autoapi/summary/","text":"polarrouteserver demo route_api models serializers tasks utils views","title":"Summary"},{"location":"autoapi/polarrouteserver/","text":"","title":"polarrouteserver"},{"location":"autoapi/polarrouteserver/demo/","text":"Demo script for requesting routes from PolarRouteServer API using Python standard library. make_request ( type , url , endpoint , headers , body = None ) Sends HTTP request, prints details and returns response. Parameters: type ( str ) \u2013 HTTP request type, e.g. \"GET\" or \"POST\" url ( str ) \u2013 base url to send request to endpoint ( str ) \u2013 endpoint, e.g. \"/api/route/some-id\" headers ( dict ) \u2013 HTTP headers body ( dict , default: None ) \u2013 HTTP request body. Defaults to None. Returns: HTTPResponse \u2013 http.client.HTTPResponse Source code in polarrouteserver/demo.py 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 def make_request ( type : str , url : str , endpoint : str , headers : dict , body : dict = None ) -> http . client . HTTPResponse : \"\"\"Sends HTTP request, prints details and returns response. Args: type (str): HTTP request type, e.g. \"GET\" or \"POST\" url (str): base url to send request to endpoint (str): endpoint, e.g. \"/api/route/some-id\" headers (dict): HTTP headers body (dict, optional): HTTP request body. Defaults to None. Returns: http.client.HTTPResponse \"\"\" sending_str = f \"Sending { type } request to { url }{ endpoint } : \\n Headers: { headers } \\n \" if body : sending_str += f \"Body: { body } \\n \" print ( sending_str ) # data = parse.urlencode(body).encode(\"utf-8\") if body else None req = request . Request ( url + endpoint , data = body , headers = headers ) unverified_context = ssl . _create_unverified_context () response = request . urlopen ( req , context = unverified_context ) print ( f \"Response: { response . status } { response . reason } \" ) return json . loads ( response . read ()), response . status parse_location ( location ) Parameters: location ( str ) \u2013 a location either as the name of a standard location or latitude,longitude separated by a comma, e.g. -56.7,-65.01 Returns: Location \u2013 a Location object Source code in polarrouteserver/demo.py 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 def parse_location ( location : str ) -> Location : \"\"\" Args: location (str): a location either as the name of a standard location or latitude,longitude separated by a comma, e.g. -56.7,-65.01 Returns: a Location object \"\"\" pattern = r \"[+-]?([0-9]*[.])?[0-9]+,[+-]?([0-9]*[.])?[0-9]+\" if location in STANDARD_LOCATIONS . keys (): standard_location = STANDARD_LOCATIONS . get ( location ) return standard_location elif re . search ( pattern , location ): coords = re . search ( pattern , location ) . group () . split ( \",\" ) return Location ( float ( coords [ 0 ]), float ( coords [ 1 ])) else : raise ValueError ( f \"Expected input as the name of a standard location or latitude,longitude separated by a comma, e.g. -56.7,-65.01, got { location } \" ) request_route ( url , start , end , status_update_delay = 30 , num_requests = 10 , force_recalculation = False , mesh_id = None ) Requests a route from polarRouteServer, repeating the request for status until the route is available. Parameters: url ( str ) \u2013 Base URL to send request to. start ( Location ) \u2013 Start location of route end ( Location ) \u2013 End location of route status_update_delay ( int , default: 30 ) \u2013 Delay in seconds between each status request. Defaults to 10. num_requests ( int , default: 10 ) \u2013 Max number of status requests before giving up. Defaults to 10. force_recalculation ( bool , default: False ) \u2013 Force recalculation of an already existing route. Default: False. Raises: Exception \u2013 If no status URL is returned. Returns: str ( str ) \u2013 JSON response of route request. Source code in polarrouteserver/demo.py 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 def request_route ( url : str , start : Location , end : Location , status_update_delay : int = 30 , num_requests : int = 10 , force_recalculation : bool = False , mesh_id : int = None , ) -> str : \"\"\"Requests a route from polarRouteServer, repeating the request for status until the route is available. Args: url (str): Base URL to send request to. start (Location): Start location of route end (Location): End location of route status_update_delay (int, optional): Delay in seconds between each status request. Defaults to 10. num_requests (int, optional): Max number of status requests before giving up. Defaults to 10. force_recalculation (bool, optional): Force recalculation of an already existing route. Default: False. Raises: Exception: If no status URL is returned. Returns: str: JSON response of route request. \"\"\" # make route request response_body , status = make_request ( \"POST\" , url , \"/api/route\" , { \"Content-Type\" : \"application/json\" }, json . dumps ( { \"start_lat\" : start . lat , \"start_lon\" : start . lon , \"end_lat\" : end . lat , \"end_lon\" : end . lon , \"start_name\" : start . name , \"end_name\" : end . name , \"force_recalculate\" : force_recalculation , \"mesh_id\" : mesh_id , }, ) . encode ( \"utf-8\" ), ) print ( pprint . pprint ( response_body )) if not str ( status ) . startswith ( \"2\" ): return None # if route is returned if response_body . get ( \"json\" ) is not None : return response_body [ \"json\" ] # if no route returned, request status at status-url status_url = response_body . get ( \"status-url\" ) if status_url is None : raise Exception ( \"No status URL returned.\" ) id = response_body . get ( \"id\" ) status_request_count = 0 while status_request_count <= num_requests : status_request_count += 1 print ( f \" \\n Waiting for { status_update_delay } seconds before sending status request.\" ) time . sleep ( status_update_delay ) # make route request print ( f \"Status request # { status_request_count } of { num_requests } \" ) response_body , status = make_request ( \"GET\" , url , f \"/api/route/ { id } \" , headers = { \"Content-Type\" : \"application/json\" }, ) print ( f \"Route calculation { response_body . get ( 'status' ) } .\" ) print ( pprint . pprint ( response_body )) if response_body . get ( \"status\" ) == \"PENDING\" : continue elif response_body . get ( \"status\" ) == \"FAILURE\" : return None elif response_body . get ( \"status\" ) == \"SUCCESS\" : return response_body . get ( \"json\" ) print ( f 'Max number of requests sent. Quitting. \\n To send more status requests, run: \"curl { url } /api/route/ { id } \"' ) return None","title":"demo"},{"location":"autoapi/polarrouteserver/demo/#polarrouteserver.demo.make_request","text":"Sends HTTP request, prints details and returns response. Parameters: type ( str ) \u2013 HTTP request type, e.g. \"GET\" or \"POST\" url ( str ) \u2013 base url to send request to endpoint ( str ) \u2013 endpoint, e.g. \"/api/route/some-id\" headers ( dict ) \u2013 HTTP headers body ( dict , default: None ) \u2013 HTTP request body. Defaults to None. Returns: HTTPResponse \u2013 http.client.HTTPResponse Source code in polarrouteserver/demo.py 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 def make_request ( type : str , url : str , endpoint : str , headers : dict , body : dict = None ) -> http . client . HTTPResponse : \"\"\"Sends HTTP request, prints details and returns response. Args: type (str): HTTP request type, e.g. \"GET\" or \"POST\" url (str): base url to send request to endpoint (str): endpoint, e.g. \"/api/route/some-id\" headers (dict): HTTP headers body (dict, optional): HTTP request body. Defaults to None. Returns: http.client.HTTPResponse \"\"\" sending_str = f \"Sending { type } request to { url }{ endpoint } : \\n Headers: { headers } \\n \" if body : sending_str += f \"Body: { body } \\n \" print ( sending_str ) # data = parse.urlencode(body).encode(\"utf-8\") if body else None req = request . Request ( url + endpoint , data = body , headers = headers ) unverified_context = ssl . _create_unverified_context () response = request . urlopen ( req , context = unverified_context ) print ( f \"Response: { response . status } { response . reason } \" ) return json . loads ( response . read ()), response . status","title":"make_request"},{"location":"autoapi/polarrouteserver/demo/#polarrouteserver.demo.parse_location","text":"Parameters: location ( str ) \u2013 a location either as the name of a standard location or latitude,longitude separated by a comma, e.g. -56.7,-65.01 Returns: Location \u2013 a Location object Source code in polarrouteserver/demo.py 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 def parse_location ( location : str ) -> Location : \"\"\" Args: location (str): a location either as the name of a standard location or latitude,longitude separated by a comma, e.g. -56.7,-65.01 Returns: a Location object \"\"\" pattern = r \"[+-]?([0-9]*[.])?[0-9]+,[+-]?([0-9]*[.])?[0-9]+\" if location in STANDARD_LOCATIONS . keys (): standard_location = STANDARD_LOCATIONS . get ( location ) return standard_location elif re . search ( pattern , location ): coords = re . search ( pattern , location ) . group () . split ( \",\" ) return Location ( float ( coords [ 0 ]), float ( coords [ 1 ])) else : raise ValueError ( f \"Expected input as the name of a standard location or latitude,longitude separated by a comma, e.g. -56.7,-65.01, got { location } \" )","title":"parse_location"},{"location":"autoapi/polarrouteserver/demo/#polarrouteserver.demo.request_route","text":"Requests a route from polarRouteServer, repeating the request for status until the route is available. Parameters: url ( str ) \u2013 Base URL to send request to. start ( Location ) \u2013 Start location of route end ( Location ) \u2013 End location of route status_update_delay ( int , default: 30 ) \u2013 Delay in seconds between each status request. Defaults to 10. num_requests ( int , default: 10 ) \u2013 Max number of status requests before giving up. Defaults to 10. force_recalculation ( bool , default: False ) \u2013 Force recalculation of an already existing route. Default: False. Raises: Exception \u2013 If no status URL is returned. Returns: str ( str ) \u2013 JSON response of route request. Source code in polarrouteserver/demo.py 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 def request_route ( url : str , start : Location , end : Location , status_update_delay : int = 30 , num_requests : int = 10 , force_recalculation : bool = False , mesh_id : int = None , ) -> str : \"\"\"Requests a route from polarRouteServer, repeating the request for status until the route is available. Args: url (str): Base URL to send request to. start (Location): Start location of route end (Location): End location of route status_update_delay (int, optional): Delay in seconds between each status request. Defaults to 10. num_requests (int, optional): Max number of status requests before giving up. Defaults to 10. force_recalculation (bool, optional): Force recalculation of an already existing route. Default: False. Raises: Exception: If no status URL is returned. Returns: str: JSON response of route request. \"\"\" # make route request response_body , status = make_request ( \"POST\" , url , \"/api/route\" , { \"Content-Type\" : \"application/json\" }, json . dumps ( { \"start_lat\" : start . lat , \"start_lon\" : start . lon , \"end_lat\" : end . lat , \"end_lon\" : end . lon , \"start_name\" : start . name , \"end_name\" : end . name , \"force_recalculate\" : force_recalculation , \"mesh_id\" : mesh_id , }, ) . encode ( \"utf-8\" ), ) print ( pprint . pprint ( response_body )) if not str ( status ) . startswith ( \"2\" ): return None # if route is returned if response_body . get ( \"json\" ) is not None : return response_body [ \"json\" ] # if no route returned, request status at status-url status_url = response_body . get ( \"status-url\" ) if status_url is None : raise Exception ( \"No status URL returned.\" ) id = response_body . get ( \"id\" ) status_request_count = 0 while status_request_count <= num_requests : status_request_count += 1 print ( f \" \\n Waiting for { status_update_delay } seconds before sending status request.\" ) time . sleep ( status_update_delay ) # make route request print ( f \"Status request # { status_request_count } of { num_requests } \" ) response_body , status = make_request ( \"GET\" , url , f \"/api/route/ { id } \" , headers = { \"Content-Type\" : \"application/json\" }, ) print ( f \"Route calculation { response_body . get ( 'status' ) } .\" ) print ( pprint . pprint ( response_body )) if response_body . get ( \"status\" ) == \"PENDING\" : continue elif response_body . get ( \"status\" ) == \"FAILURE\" : return None elif response_body . get ( \"status\" ) == \"SUCCESS\" : return response_body . get ( \"json\" ) print ( f 'Max number of requests sent. Quitting. \\n To send more status requests, run: \"curl { url } /api/route/ { id } \"' ) return None","title":"request_route"},{"location":"autoapi/polarrouteserver/route_api/","text":"","title":"route_api"},{"location":"autoapi/polarrouteserver/route_api/models/","text":"Job Bases: Model Route or mesh calculation jobs Source code in polarrouteserver/route_api/models.py 52 53 54 55 56 57 58 59 60 61 62 63 64 65 class Job ( models . Model ): \"Route or mesh calculation jobs\" id = models . UUIDField ( primary_key = True ) # use uuids for primary keys to align with celery datetime = models . DateTimeField ( default = timezone . now ) route = models . ForeignKey ( Route , on_delete = models . SET_NULL , null = True ) @property def status ( self ): result = AsyncResult ( self . id , app = app ) return result . state Mesh Bases: Model Source code in polarrouteserver/route_api/models.py 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 class Mesh ( models . Model ): id = models . BigAutoField ( primary_key = True ) meshiphi_version = models . CharField ( max_length = 60 , null = True ) md5 = models . CharField ( max_length = 64 ) valid_date_start = models . DateField () valid_date_end = models . DateField () created = models . DateTimeField () lat_min = models . FloatField () lat_max = models . FloatField () lon_min = models . FloatField () lon_max = models . FloatField () json = models . JSONField ( null = True ) name = models . CharField ( max_length = 150 , null = True ) @property def size ( self ) -> float : \"\"\"Computes a metric for the size of a mesh.\"\"\" return abs ( self . lat_max - self . lat_min ) * abs ( self . lon_max - self . lon_min ) class Meta : verbose_name_plural = \"Meshes\" size property Computes a metric for the size of a mesh.","title":"models"},{"location":"autoapi/polarrouteserver/route_api/models/#polarrouteserver.route_api.models.Job","text":"Bases: Model Route or mesh calculation jobs Source code in polarrouteserver/route_api/models.py 52 53 54 55 56 57 58 59 60 61 62 63 64 65 class Job ( models . Model ): \"Route or mesh calculation jobs\" id = models . UUIDField ( primary_key = True ) # use uuids for primary keys to align with celery datetime = models . DateTimeField ( default = timezone . now ) route = models . ForeignKey ( Route , on_delete = models . SET_NULL , null = True ) @property def status ( self ): result = AsyncResult ( self . id , app = app ) return result . state","title":"Job"},{"location":"autoapi/polarrouteserver/route_api/models/#polarrouteserver.route_api.models.Mesh","text":"Bases: Model Source code in polarrouteserver/route_api/models.py 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 class Mesh ( models . Model ): id = models . BigAutoField ( primary_key = True ) meshiphi_version = models . CharField ( max_length = 60 , null = True ) md5 = models . CharField ( max_length = 64 ) valid_date_start = models . DateField () valid_date_end = models . DateField () created = models . DateTimeField () lat_min = models . FloatField () lat_max = models . FloatField () lon_min = models . FloatField () lon_max = models . FloatField () json = models . JSONField ( null = True ) name = models . CharField ( max_length = 150 , null = True ) @property def size ( self ) -> float : \"\"\"Computes a metric for the size of a mesh.\"\"\" return abs ( self . lat_max - self . lat_min ) * abs ( self . lon_max - self . lon_min ) class Meta : verbose_name_plural = \"Meshes\"","title":"Mesh"},{"location":"autoapi/polarrouteserver/route_api/models/#polarrouteserver.route_api.models.Mesh.size","text":"Computes a metric for the size of a mesh.","title":"size"},{"location":"autoapi/polarrouteserver/route_api/serializers/","text":"RouteSerializer Bases: ModelSerializer Source code in polarrouteserver/route_api/serializers.py 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 class RouteSerializer ( serializers . ModelSerializer ): class Meta : model = Route fields = [ \"start_lat\" , \"start_lon\" , \"end_lat\" , \"end_lon\" , \"start_name\" , \"end_name\" , \"json\" , \"json_unsmoothed\" , \"polar_route_version\" , \"info\" , \"mesh\" , ] def to_representation ( self , instance ): \"\"\"Returns unsmoothed routes if available when smoothed routes have failed.\"\"\" data = super () . to_representation ( instance ) smoothed = {} unsmoothed = {} data [ \"json\" ] = [] for key in ( \"traveltime\" , \"fuel\" ): smoothed [ key ] = ( [ x for x in data [ \"json\" ] if x [ 0 ][ \"features\" ][ 0 ][ \"properties\" ][ \"objective_function\" ] == key ] if data [ \"json\" ] is not None else [] ) unsmoothed [ key ] = ( [ x for x in data [ \"json_unsmoothed\" ] if x [ 0 ][ \"features\" ][ 0 ][ \"properties\" ][ \"objective_function\" ] == key ] if data [ \"json_unsmoothed\" ] is not None else [] ) # if there is no smoothed route available, use unsmoothed in its place if len ( smoothed [ key ]) == 0 and len ( unsmoothed [ key ]) == 1 : data [ \"json\" ] . extend ( unsmoothed [ key ]) data [ \"info\" ] = { \"error\" : f \"Smoothing failed for { key } -optimisation, returning unsmoothed route.\" } elif len ( smoothed [ key ]) == 0 and len ( unsmoothed [ key ]) == 0 : data [ \"info\" ] = { \"error\" : f \"No routes available for { key } -optimisation.\" } else : data [ \"json\" ] . extend ( unsmoothed [ key ]) return data to_representation ( instance ) Returns unsmoothed routes if available when smoothed routes have failed. Source code in polarrouteserver/route_api/serializers.py 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 def to_representation ( self , instance ): \"\"\"Returns unsmoothed routes if available when smoothed routes have failed.\"\"\" data = super () . to_representation ( instance ) smoothed = {} unsmoothed = {} data [ \"json\" ] = [] for key in ( \"traveltime\" , \"fuel\" ): smoothed [ key ] = ( [ x for x in data [ \"json\" ] if x [ 0 ][ \"features\" ][ 0 ][ \"properties\" ][ \"objective_function\" ] == key ] if data [ \"json\" ] is not None else [] ) unsmoothed [ key ] = ( [ x for x in data [ \"json_unsmoothed\" ] if x [ 0 ][ \"features\" ][ 0 ][ \"properties\" ][ \"objective_function\" ] == key ] if data [ \"json_unsmoothed\" ] is not None else [] ) # if there is no smoothed route available, use unsmoothed in its place if len ( smoothed [ key ]) == 0 and len ( unsmoothed [ key ]) == 1 : data [ \"json\" ] . extend ( unsmoothed [ key ]) data [ \"info\" ] = { \"error\" : f \"Smoothing failed for { key } -optimisation, returning unsmoothed route.\" } elif len ( smoothed [ key ]) == 0 and len ( unsmoothed [ key ]) == 0 : data [ \"info\" ] = { \"error\" : f \"No routes available for { key } -optimisation.\" } else : data [ \"json\" ] . extend ( unsmoothed [ key ]) return data","title":"serializers"},{"location":"autoapi/polarrouteserver/route_api/serializers/#polarrouteserver.route_api.serializers.RouteSerializer","text":"Bases: ModelSerializer Source code in polarrouteserver/route_api/serializers.py 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 class RouteSerializer ( serializers . ModelSerializer ): class Meta : model = Route fields = [ \"start_lat\" , \"start_lon\" , \"end_lat\" , \"end_lon\" , \"start_name\" , \"end_name\" , \"json\" , \"json_unsmoothed\" , \"polar_route_version\" , \"info\" , \"mesh\" , ] def to_representation ( self , instance ): \"\"\"Returns unsmoothed routes if available when smoothed routes have failed.\"\"\" data = super () . to_representation ( instance ) smoothed = {} unsmoothed = {} data [ \"json\" ] = [] for key in ( \"traveltime\" , \"fuel\" ): smoothed [ key ] = ( [ x for x in data [ \"json\" ] if x [ 0 ][ \"features\" ][ 0 ][ \"properties\" ][ \"objective_function\" ] == key ] if data [ \"json\" ] is not None else [] ) unsmoothed [ key ] = ( [ x for x in data [ \"json_unsmoothed\" ] if x [ 0 ][ \"features\" ][ 0 ][ \"properties\" ][ \"objective_function\" ] == key ] if data [ \"json_unsmoothed\" ] is not None else [] ) # if there is no smoothed route available, use unsmoothed in its place if len ( smoothed [ key ]) == 0 and len ( unsmoothed [ key ]) == 1 : data [ \"json\" ] . extend ( unsmoothed [ key ]) data [ \"info\" ] = { \"error\" : f \"Smoothing failed for { key } -optimisation, returning unsmoothed route.\" } elif len ( smoothed [ key ]) == 0 and len ( unsmoothed [ key ]) == 0 : data [ \"info\" ] = { \"error\" : f \"No routes available for { key } -optimisation.\" } else : data [ \"json\" ] . extend ( unsmoothed [ key ]) return data","title":"RouteSerializer"},{"location":"autoapi/polarrouteserver/route_api/serializers/#polarrouteserver.route_api.serializers.RouteSerializer.to_representation","text":"Returns unsmoothed routes if available when smoothed routes have failed. Source code in polarrouteserver/route_api/serializers.py 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 def to_representation ( self , instance ): \"\"\"Returns unsmoothed routes if available when smoothed routes have failed.\"\"\" data = super () . to_representation ( instance ) smoothed = {} unsmoothed = {} data [ \"json\" ] = [] for key in ( \"traveltime\" , \"fuel\" ): smoothed [ key ] = ( [ x for x in data [ \"json\" ] if x [ 0 ][ \"features\" ][ 0 ][ \"properties\" ][ \"objective_function\" ] == key ] if data [ \"json\" ] is not None else [] ) unsmoothed [ key ] = ( [ x for x in data [ \"json_unsmoothed\" ] if x [ 0 ][ \"features\" ][ 0 ][ \"properties\" ][ \"objective_function\" ] == key ] if data [ \"json_unsmoothed\" ] is not None else [] ) # if there is no smoothed route available, use unsmoothed in its place if len ( smoothed [ key ]) == 0 and len ( unsmoothed [ key ]) == 1 : data [ \"json\" ] . extend ( unsmoothed [ key ]) data [ \"info\" ] = { \"error\" : f \"Smoothing failed for { key } -optimisation, returning unsmoothed route.\" } elif len ( smoothed [ key ]) == 0 and len ( unsmoothed [ key ]) == 0 : data [ \"info\" ] = { \"error\" : f \"No routes available for { key } -optimisation.\" } else : data [ \"json\" ] . extend ( unsmoothed [ key ]) return data","title":"to_representation"},{"location":"autoapi/polarrouteserver/route_api/tasks/","text":"import_new_meshes ( self ) Look for new meshes and insert them into the database. Source code in polarrouteserver/route_api/tasks.py 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 @app . task ( bind = True ) def import_new_meshes ( self ): \"\"\"Look for new meshes and insert them into the database.\"\"\" if settings . MESH_METADATA_DIR is None : raise ValueError ( \"MESH_METADATA_DIR has not been set.\" ) # find the latest metadata file files = os . listdir ( settings . MESH_METADATA_DIR ) file_list = [ os . path . join ( settings . MESH_METADATA_DIR , file ) for file in files if file . startswith ( \"upload_metadata_\" ) and file . endswith ( \".yaml.gz\" ) ] if len ( file_list ) == 0 : msg = \"Upload metadata file not found.\" logger . error ( msg ) return latest_metadata_file = max ( file_list , key = os . path . getctime ) # load in the metadata logger . info ( f \"Loading metadata file from { os . path . join ( settings . MESH_METADATA_DIR , latest_metadata_file ) } \" ) with gzip . open ( latest_metadata_file , \"rb\" ) as f : metadata = yaml . load ( f . read (), Loader = yaml . Loader ) meshes_added = [] for record in metadata [ \"records\" ]: # we only want the vessel json files if not bool ( re . search ( VESSEL_MESH_FILENAME_PATTERN , record [ \"filepath\" ])): continue # extract the filename from the filepath mesh_filename = record [ \"filepath\" ] . split ( \"/\" )[ - 1 ] # load in the mesh json try : zipped_filename = mesh_filename + \".gz\" with gzip . open ( Path ( settings . MESH_DIR , zipped_filename ), \"rb\" ) as gzipped_mesh : mesh_json = json . load ( gzipped_mesh ) except FileNotFoundError : logger . warning ( f \" { zipped_filename } not found. Skipping.\" ) continue except PermissionError : logger . warning ( f \"Can't read { zipped_filename } due to permission error. File may still be transferring. Skipping.\" ) continue # write out the unzipped mesh to temp file tfile = tempfile . NamedTemporaryFile ( mode = \"w+\" , delete = True ) json . dump ( mesh_json , tfile , indent = 4 ) tfile . flush () md5 = calculate_md5 ( tfile . name ) # cross reference md5 hash from file record in metadata to actual file on disk if md5 != record [ \"md5\" ]: logger . warning ( f \"Mesh file md5: { md5 } \\n\\ does not match \\n\\ Metadata md5: { record [ 'md5' ] } \\n\\ Skipping.\" ) # if md5 hash from metadata file does not match that of the file itself, # there may have been a filename clash, skip this one. continue # create an entry in the database mesh , created = Mesh . objects . get_or_create ( md5 = md5 , defaults = { \"name\" : mesh_filename , \"valid_date_start\" : datetime . datetime . strptime ( mesh_json [ \"config\" ][ \"mesh_info\" ][ \"region\" ][ \"start_time\" ], \"%Y-%m- %d \" ) . replace ( tzinfo = datetime . timezone . utc ), \"valid_date_end\" : datetime . datetime . strptime ( mesh_json [ \"config\" ][ \"mesh_info\" ][ \"region\" ][ \"end_time\" ], \"%Y-%m- %d \" ) . replace ( tzinfo = datetime . timezone . utc ), \"created\" : datetime . datetime . strptime ( record [ \"created\" ], \"%Y%m %d T%H%M%S\" ) . replace ( tzinfo = datetime . timezone . utc ), \"json\" : mesh_json , \"meshiphi_version\" : record [ \"meshiphi\" ], \"lat_min\" : record [ \"latlong\" ][ \"latmin\" ], \"lat_max\" : record [ \"latlong\" ][ \"latmax\" ], \"lon_min\" : record [ \"latlong\" ][ \"lonmin\" ], \"lon_max\" : record [ \"latlong\" ][ \"lonmax\" ], }, ) if created : logger . info ( f \"Adding new mesh to database: { mesh . id } { mesh . name } { mesh . created } \" ) meshes_added . append ( { \"id\" : mesh . id , \"md5\" : record [ \"md5\" ], \"name\" : mesh . name } ) return meshes_added optimise_route ( self , route_id , backup_mesh_ids = None ) Use PolarRoute to calculate optimal route from Route database object and mesh. Saves Route in database and returns route geojson as dictionary. Parameters: route_id ( int ) \u2013 id of record in Route database table backup_mesh_ids ( list , default: None ) \u2013 list of database ids of backup meshes to try in order of priority Returns: dict \u2013 route geojson as dictionary Source code in polarrouteserver/route_api/tasks.py 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 @app . task ( bind = True ) def optimise_route ( self , route_id : int , backup_mesh_ids : list [ int ] = None , ) -> dict : \"\"\" Use PolarRoute to calculate optimal route from Route database object and mesh. Saves Route in database and returns route geojson as dictionary. Params: route_id: id of record in Route database table backup_mesh_ids list: list of database ids of backup meshes to try in order of priority Returns: route geojson as dictionary \"\"\" route = Route . objects . get ( id = route_id ) mesh = route . mesh logger . info ( f \"Running optimisation for route { route . id } \" ) logger . info ( f \"Using mesh { mesh . id } \" ) if backup_mesh_ids : logger . info ( f \"Also got backup mesh ids { backup_mesh_ids } \" ) # add warning on mesh date if older than today if mesh . created . date () < datetime . datetime . now () . date (): route . info = { \"info\" : f \"Latest available mesh from { datetime . datetime . strftime ( mesh . created , '%Y/%m/ %d %H:%M%S' ) } \" } data_warning_message = check_mesh_data ( mesh ) if data_warning_message is not \"\" : if route . info is None : route . info = { \"info\" : data_warning_message } else : route . info [ \"info\" ] = route . info [ \"info\" ] + data_warning_message # convert waypoints into pandas dataframe for PolarRoute waypoints = pd . DataFrame ( { \"Name\" : [ \"Start\" if route . start_name is None else route . start_name , \"End\" if route . end_name is None else route . end_name , ], \"Lat\" : [ route . start_lat , route . end_lat ], \"Long\" : [ route . start_lon , route . end_lon ], \"Source\" : [ \"X\" , np . nan ], \"Destination\" : [ np . nan , \"X\" ], } ) try : unsmoothed_routes = [] route_planners = [] configs = ( settings . TRAVELTIME_CONFIG , settings . FUEL_CONFIG , ) for config in configs : rp = RoutePlanner ( copy . deepcopy ( mesh . json ), config ) # Calculate optimal dijkstra path between waypoints rp . compute_routes ( waypoints ) route_planners . append ( rp ) # save the initial unsmoothed route logger . info ( f \"Saving unsmoothed Dijkstra paths for { config [ 'objective_function' ] } -optimised route.\" ) if len ( rp . routes_dijkstra ) == 0 : raise ValueError ( \"Inaccessible. No routes found.\" ) route_geojson = extract_geojson_routes ( rp . to_json ()) route_geojson [ 0 ][ \"features\" ][ 0 ][ \"properties\" ][ \"objective_function\" ] = ( config [ \"objective_function\" ] ) unsmoothed_routes . append ( route_geojson ) route . json_unsmoothed = unsmoothed_routes route . calculated = timezone . now () route . polar_route_version = polar_route . __version__ route . save () smoothed_routes = [] for i , rp in enumerate ( route_planners ): # Smooth the dijkstra routes rp . compute_smoothed_routes () # Save the smoothed route(s) logger . info ( f \"Route smoothing { i + 1 } / { len ( route_planners ) } complete.\" ) route_geojson = extract_geojson_routes ( rp . to_json ()) route_geojson [ 0 ][ \"features\" ][ 0 ][ \"properties\" ][ \"objective_function\" ] = ( rp . config [ \"objective_function\" ] ) smoothed_routes . append ( route_geojson ) # Update the database route . json = smoothed_routes route . calculated = timezone . now () route . polar_route_version = polar_route . __version__ route . save () return smoothed_routes except Exception as e : logger . error ( e ) self . update_state ( state = states . FAILURE ) # this is awful, polar route should raise a custom error class if \"Inaccessible. No routes found\" in e . args [ 0 ] and len ( backup_mesh_ids ) > 0 : # if route is inaccesible in the mesh, try again if backup meshes are provided logger . info ( f \"No routes found on mesh { mesh . id } , trying with next mesh(es) { backup_mesh_ids } \" ) route . info = { \"info\" : \"Route inaccessible on mesh, trying next mesh.\" } route . mesh = Mesh . objects . get ( id = backup_mesh_ids [ 0 ]) route . save () task = optimise_route . delay ( route . id , backup_mesh_ids [ 1 :]) _ = Job . objects . create ( id = task . id , route = route , ) raise Ignore () else : route . info = { \"error\" : f \" { e } \" } route . save () raise Ignore ()","title":"tasks"},{"location":"autoapi/polarrouteserver/route_api/tasks/#polarrouteserver.route_api.tasks.import_new_meshes","text":"Look for new meshes and insert them into the database. Source code in polarrouteserver/route_api/tasks.py 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 @app . task ( bind = True ) def import_new_meshes ( self ): \"\"\"Look for new meshes and insert them into the database.\"\"\" if settings . MESH_METADATA_DIR is None : raise ValueError ( \"MESH_METADATA_DIR has not been set.\" ) # find the latest metadata file files = os . listdir ( settings . MESH_METADATA_DIR ) file_list = [ os . path . join ( settings . MESH_METADATA_DIR , file ) for file in files if file . startswith ( \"upload_metadata_\" ) and file . endswith ( \".yaml.gz\" ) ] if len ( file_list ) == 0 : msg = \"Upload metadata file not found.\" logger . error ( msg ) return latest_metadata_file = max ( file_list , key = os . path . getctime ) # load in the metadata logger . info ( f \"Loading metadata file from { os . path . join ( settings . MESH_METADATA_DIR , latest_metadata_file ) } \" ) with gzip . open ( latest_metadata_file , \"rb\" ) as f : metadata = yaml . load ( f . read (), Loader = yaml . Loader ) meshes_added = [] for record in metadata [ \"records\" ]: # we only want the vessel json files if not bool ( re . search ( VESSEL_MESH_FILENAME_PATTERN , record [ \"filepath\" ])): continue # extract the filename from the filepath mesh_filename = record [ \"filepath\" ] . split ( \"/\" )[ - 1 ] # load in the mesh json try : zipped_filename = mesh_filename + \".gz\" with gzip . open ( Path ( settings . MESH_DIR , zipped_filename ), \"rb\" ) as gzipped_mesh : mesh_json = json . load ( gzipped_mesh ) except FileNotFoundError : logger . warning ( f \" { zipped_filename } not found. Skipping.\" ) continue except PermissionError : logger . warning ( f \"Can't read { zipped_filename } due to permission error. File may still be transferring. Skipping.\" ) continue # write out the unzipped mesh to temp file tfile = tempfile . NamedTemporaryFile ( mode = \"w+\" , delete = True ) json . dump ( mesh_json , tfile , indent = 4 ) tfile . flush () md5 = calculate_md5 ( tfile . name ) # cross reference md5 hash from file record in metadata to actual file on disk if md5 != record [ \"md5\" ]: logger . warning ( f \"Mesh file md5: { md5 } \\n\\ does not match \\n\\ Metadata md5: { record [ 'md5' ] } \\n\\ Skipping.\" ) # if md5 hash from metadata file does not match that of the file itself, # there may have been a filename clash, skip this one. continue # create an entry in the database mesh , created = Mesh . objects . get_or_create ( md5 = md5 , defaults = { \"name\" : mesh_filename , \"valid_date_start\" : datetime . datetime . strptime ( mesh_json [ \"config\" ][ \"mesh_info\" ][ \"region\" ][ \"start_time\" ], \"%Y-%m- %d \" ) . replace ( tzinfo = datetime . timezone . utc ), \"valid_date_end\" : datetime . datetime . strptime ( mesh_json [ \"config\" ][ \"mesh_info\" ][ \"region\" ][ \"end_time\" ], \"%Y-%m- %d \" ) . replace ( tzinfo = datetime . timezone . utc ), \"created\" : datetime . datetime . strptime ( record [ \"created\" ], \"%Y%m %d T%H%M%S\" ) . replace ( tzinfo = datetime . timezone . utc ), \"json\" : mesh_json , \"meshiphi_version\" : record [ \"meshiphi\" ], \"lat_min\" : record [ \"latlong\" ][ \"latmin\" ], \"lat_max\" : record [ \"latlong\" ][ \"latmax\" ], \"lon_min\" : record [ \"latlong\" ][ \"lonmin\" ], \"lon_max\" : record [ \"latlong\" ][ \"lonmax\" ], }, ) if created : logger . info ( f \"Adding new mesh to database: { mesh . id } { mesh . name } { mesh . created } \" ) meshes_added . append ( { \"id\" : mesh . id , \"md5\" : record [ \"md5\" ], \"name\" : mesh . name } ) return meshes_added","title":"import_new_meshes"},{"location":"autoapi/polarrouteserver/route_api/tasks/#polarrouteserver.route_api.tasks.optimise_route","text":"Use PolarRoute to calculate optimal route from Route database object and mesh. Saves Route in database and returns route geojson as dictionary. Parameters: route_id ( int ) \u2013 id of record in Route database table backup_mesh_ids ( list , default: None ) \u2013 list of database ids of backup meshes to try in order of priority Returns: dict \u2013 route geojson as dictionary Source code in polarrouteserver/route_api/tasks.py 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 @app . task ( bind = True ) def optimise_route ( self , route_id : int , backup_mesh_ids : list [ int ] = None , ) -> dict : \"\"\" Use PolarRoute to calculate optimal route from Route database object and mesh. Saves Route in database and returns route geojson as dictionary. Params: route_id: id of record in Route database table backup_mesh_ids list: list of database ids of backup meshes to try in order of priority Returns: route geojson as dictionary \"\"\" route = Route . objects . get ( id = route_id ) mesh = route . mesh logger . info ( f \"Running optimisation for route { route . id } \" ) logger . info ( f \"Using mesh { mesh . id } \" ) if backup_mesh_ids : logger . info ( f \"Also got backup mesh ids { backup_mesh_ids } \" ) # add warning on mesh date if older than today if mesh . created . date () < datetime . datetime . now () . date (): route . info = { \"info\" : f \"Latest available mesh from { datetime . datetime . strftime ( mesh . created , '%Y/%m/ %d %H:%M%S' ) } \" } data_warning_message = check_mesh_data ( mesh ) if data_warning_message is not \"\" : if route . info is None : route . info = { \"info\" : data_warning_message } else : route . info [ \"info\" ] = route . info [ \"info\" ] + data_warning_message # convert waypoints into pandas dataframe for PolarRoute waypoints = pd . DataFrame ( { \"Name\" : [ \"Start\" if route . start_name is None else route . start_name , \"End\" if route . end_name is None else route . end_name , ], \"Lat\" : [ route . start_lat , route . end_lat ], \"Long\" : [ route . start_lon , route . end_lon ], \"Source\" : [ \"X\" , np . nan ], \"Destination\" : [ np . nan , \"X\" ], } ) try : unsmoothed_routes = [] route_planners = [] configs = ( settings . TRAVELTIME_CONFIG , settings . FUEL_CONFIG , ) for config in configs : rp = RoutePlanner ( copy . deepcopy ( mesh . json ), config ) # Calculate optimal dijkstra path between waypoints rp . compute_routes ( waypoints ) route_planners . append ( rp ) # save the initial unsmoothed route logger . info ( f \"Saving unsmoothed Dijkstra paths for { config [ 'objective_function' ] } -optimised route.\" ) if len ( rp . routes_dijkstra ) == 0 : raise ValueError ( \"Inaccessible. No routes found.\" ) route_geojson = extract_geojson_routes ( rp . to_json ()) route_geojson [ 0 ][ \"features\" ][ 0 ][ \"properties\" ][ \"objective_function\" ] = ( config [ \"objective_function\" ] ) unsmoothed_routes . append ( route_geojson ) route . json_unsmoothed = unsmoothed_routes route . calculated = timezone . now () route . polar_route_version = polar_route . __version__ route . save () smoothed_routes = [] for i , rp in enumerate ( route_planners ): # Smooth the dijkstra routes rp . compute_smoothed_routes () # Save the smoothed route(s) logger . info ( f \"Route smoothing { i + 1 } / { len ( route_planners ) } complete.\" ) route_geojson = extract_geojson_routes ( rp . to_json ()) route_geojson [ 0 ][ \"features\" ][ 0 ][ \"properties\" ][ \"objective_function\" ] = ( rp . config [ \"objective_function\" ] ) smoothed_routes . append ( route_geojson ) # Update the database route . json = smoothed_routes route . calculated = timezone . now () route . polar_route_version = polar_route . __version__ route . save () return smoothed_routes except Exception as e : logger . error ( e ) self . update_state ( state = states . FAILURE ) # this is awful, polar route should raise a custom error class if \"Inaccessible. No routes found\" in e . args [ 0 ] and len ( backup_mesh_ids ) > 0 : # if route is inaccesible in the mesh, try again if backup meshes are provided logger . info ( f \"No routes found on mesh { mesh . id } , trying with next mesh(es) { backup_mesh_ids } \" ) route . info = { \"info\" : \"Route inaccessible on mesh, trying next mesh.\" } route . mesh = Mesh . objects . get ( id = backup_mesh_ids [ 0 ]) route . save () task = optimise_route . delay ( route . id , backup_mesh_ids [ 1 :]) _ = Job . objects . create ( id = task . id , route = route , ) raise Ignore () else : route . info = { \"error\" : f \" { e } \" } route . save () raise Ignore ()","title":"optimise_route"},{"location":"autoapi/polarrouteserver/route_api/utils/","text":"_closest_route_in_tolerance ( routes , start_lat , start_lon , end_lat , end_lon , tolerance_nm = settings . WAYPOINT_DISTANCE_TOLERANCE ) Takes a list of routes and returns the closest if any are within tolerance, or None. Source code in polarrouteserver/route_api/utils.py 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 def _closest_route_in_tolerance ( routes : list , start_lat : float , start_lon : float , end_lat : float , end_lon : float , tolerance_nm : float = settings . WAYPOINT_DISTANCE_TOLERANCE , ) -> Union [ Route , None ]: \"\"\"Takes a list of routes and returns the closest if any are within tolerance, or None.\"\"\" def point_within_tolerance ( point_1 : tuple , point_2 : tuple ) -> bool : return haversine_distance ( point_1 , point_2 ) < tolerance_nm def haversine_distance ( point_1 : tuple , point_2 : tuple ) -> float : return haversine . haversine ( point_1 , point_2 , unit = haversine . Unit . NAUTICAL_MILES ) routes_in_tolerance = [] for route in routes : if point_within_tolerance ( ( start_lat , start_lon ), ( route . start_lat , route . start_lon ) ) and point_within_tolerance ( ( end_lat , end_lon ), ( route . end_lat , route . end_lon ) ): routes_in_tolerance . append ( { \"id\" : route . id , } ) if len ( routes_in_tolerance ) == 0 : return None elif len ( routes_in_tolerance ) == 1 : return Route . objects . get ( id = routes_in_tolerance [ 0 ][ \"id\" ]) else : for i , route_dict in enumerate ( routes_in_tolerance ): route = Route . objects . get ( id = route_dict [ \"id\" ]) routes_in_tolerance [ i ] . update ( { \"cumulative_distance\" : haversine_distance ( ( start_lat , start_lon ), ( route . start_lat , route . start_lon ) ) + haversine_distance ( ( end_lat , end_lon ), ( route . end_lat , route . end_lon ) ) } ) from operator import itemgetter closest_route = sorted ( routes_in_tolerance , key = itemgetter ( \"cumulative_distance\" ) )[ 0 ] return Route . objects . get ( id = closest_route [ \"id\" ]) calculate_md5 ( filename ) create md5sum checksum for any file Source code in polarrouteserver/route_api/utils.py 163 164 165 166 167 168 169 170 def calculate_md5 ( filename ): \"\"\"create md5sum checksum for any file\"\"\" hash_md5 = hashlib . md5 () with open ( filename , \"rb\" ) as f : for chunk in iter ( lambda : f . read ( 4096 ), b \"\" ): hash_md5 . update ( chunk ) return hash_md5 . hexdigest () check_mesh_data ( mesh ) Check a mesh object for missing data sources. Parameters: mesh ( Mesh ) \u2013 mesh object to evaluate. Returns: str \u2013 A user-friendly warning message as a string. Source code in polarrouteserver/route_api/utils.py 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 def check_mesh_data ( mesh : Mesh ) -> str : \"\"\"Check a mesh object for missing data sources. Args: mesh (Mesh): mesh object to evaluate. Returns: A user-friendly warning message as a string. \"\"\" message = \"\" mesh_data_sources = mesh . json [ 'config' ][ 'mesh_info' ] . get ( 'data_sources' , None ) # check for completely absent data sources if mesh_data_sources is None : message = \"Mesh has no data sources.\" return message expected_sources = settings . EXPECTED_MESH_DATA_SOURCES expected_num_data_files = settings . EXPECTED_MESH_DATA_FILES for data_type , data_loader in expected_sources . items (): # check for missing individual data sources data_source = [ d for d in mesh_data_sources if d [ \"loader\" ] == data_loader ] if len ( data_source ) == 0 : message += f \"No { data_type } data available for this mesh. \\n \" # skip to the next data source continue # check for unexpected number of data files data_source_num_expected_files = expected_num_data_files . get ( data_loader , None ) if data_source_num_expected_files is not None : actual_num_files = len ([ f for f in data_source [ 0 ][ \"params\" ][ \"files\" ] if f != \"\" ]) # number of files removing empty strings if actual_num_files != data_source_num_expected_files : message += f \" { actual_num_files } of expected { data_source_num_expected_files } days' data available for { data_type } . \\n \" return message evaluate_route ( route_json , mesh ) Run calculate_route method from PolarRoute to evaluate the fuel usage and travel time of a route. Parameters: route_json ( dict ) \u2013 route to evaluate in geojson format. mesh ( Mesh ) \u2013 mesh object on which to evaluate the route. Returns: dict ( dict ) \u2013 evaluated route Source code in polarrouteserver/route_api/utils.py 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 def evaluate_route ( route_json : dict , mesh : Mesh ) -> dict : \"\"\"Run calculate_route method from PolarRoute to evaluate the fuel usage and travel time of a route. Args: route_json (dict): route to evaluate in geojson format. mesh (polarrouteserver.models.Mesh): mesh object on which to evaluate the route. Returns: dict: evaluated route \"\"\" if route_json [ \"features\" ][ 0 ] . get ( \"properties\" , None ) is None : route_json [ \"features\" ][ 0 ][ \"properties\" ] = { \"from\" : \"Start\" , \"to\" : \"End\" } # route_calc only supports files, write out both route and mesh as temporary files route_file = NamedTemporaryFile ( delete = False , suffix = \".json\" ) with open ( route_file . name , \"w\" ) as fp : json . dump ( route_json , fp ) mesh_file = NamedTemporaryFile ( delete = False , suffix = \".json\" ) with open ( mesh_file . name , \"w\" ) as fp : json . dump ( mesh . json , fp ) try : calc_route = route_calc ( route_file . name , mesh_file . name ) except Exception as e : logger . error ( e ) return None finally : for file in ( route_file , mesh_file ): try : os . remove ( file . name ) except Exception as e : logger . warning ( f \" { file } not removed due to { e } \" ) time_days = calc_route [ \"features\" ][ 0 ][ \"properties\" ][ \"traveltime\" ][ - 1 ] time_str = convert_decimal_days ( time_days ) fuel = round ( calc_route [ \"features\" ][ 0 ][ \"properties\" ][ \"fuel\" ][ - 1 ], 2 ) return dict ( route = calc_route , time_days = time_days , time_str = time_str , fuel_tonnes = fuel ) route_exists ( meshes , start_lat , start_lon , end_lat , end_lon ) Check if a route of given parameters has already been calculated. Works through list of meshes in order, returns first matching route Return None if not and the route object if it has. Source code in polarrouteserver/route_api/utils.py 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 def route_exists ( meshes : Union [ Mesh , list [ Mesh ]], start_lat : float , start_lon : float , end_lat : float , end_lon : float , ) -> Union [ Route , None ]: \"\"\"Check if a route of given parameters has already been calculated. Works through list of meshes in order, returns first matching route Return None if not and the route object if it has. \"\"\" if isinstance ( meshes , Mesh ): meshes = [ meshes ] for mesh in meshes : same_mesh_routes = Route . objects . filter ( mesh = mesh ) # use set to preserve uniqueness successful_route_ids = set () # remove any failed routes for route in same_mesh_routes : # job_set can't be filtered since status is a property method for job in route . job_set . all (): if job . status != \"FAILURE\" : successful_route_ids . add ( route . id ) successful_routes = same_mesh_routes . filter ( id__in = successful_route_ids ) # if there are none return None if len ( successful_routes ) == 0 : continue else : exact_routes = successful_routes . filter ( start_lat = start_lat , start_lon = start_lon , end_lat = end_lat , end_lon = end_lon , ) if len ( exact_routes ) == 1 : return exact_routes [ 0 ] elif len ( exact_routes ) > 1 : # TODO if multiple matching routes exist, which to return? return exact_routes [ 0 ] else : # if no exact routes, look for any that are close enough return _closest_route_in_tolerance ( same_mesh_routes , start_lat , start_lon , end_lat , end_lon ) return None select_mesh ( start_lat , start_lon , end_lat , end_lon ) Find the most suitable mesh from the database for a given set of start and end coordinates. Returns either a list of Mesh objects or None. Source code in polarrouteserver/route_api/utils.py 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 def select_mesh ( start_lat : float , start_lon : float , end_lat : float , end_lon : float , ) -> Union [ list [ Mesh ], None ]: \"\"\"Find the most suitable mesh from the database for a given set of start and end coordinates. Returns either a list of Mesh objects or None. \"\"\" try : # get meshes which contain both start and end points containing_meshes = Mesh . objects . filter ( lat_min__lte = start_lat , lat_max__gte = start_lat , lon_min__lte = start_lon , lon_max__gte = start_lon , ) . filter ( lat_min__lte = end_lat , lat_max__gte = end_lat , lon_min__lte = end_lon , lon_max__gte = end_lon , ) # get the date of the most recently created mesh latest_date = containing_meshes . latest ( \"created\" ) . created . date () # get all valid meshes from that creation date valid_meshes = containing_meshes . filter ( created__date = latest_date ) # return the smallest return sorted ( valid_meshes , key = lambda mesh : mesh . size ) except Mesh . DoesNotExist : return None select_mesh_for_route_evaluation ( route ) Select a mesh from the database to be used for route evaluation. The latest mesh containing all points in the route will be chosen. If no suitable meshes are available, return None. Parameters: route ( dict ) \u2013 GeoJSON route to be evaluated. Returns: Union [ list [ Mesh ], None] \u2013 Union[Mesh,None]: Selected mesh object or None. Source code in polarrouteserver/route_api/utils.py 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 def select_mesh_for_route_evaluation ( route : dict ) -> Union [ list [ Mesh ], None ]: \"\"\"Select a mesh from the database to be used for route evaluation. The latest mesh containing all points in the route will be chosen. If no suitable meshes are available, return None. Args: route (dict): GeoJSON route to be evaluated. Returns: Union[Mesh,None]: Selected mesh object or None. \"\"\" coordinates = route [ \"features\" ][ 0 ][ \"geometry\" ][ \"coordinates\" ] lats = [ c [ 0 ] for c in coordinates ] lons = [ c [ 1 ] for c in coordinates ] return select_mesh ( min ( lats ), min ( lons ), max ( lats ), max ( lons ))","title":"utils"},{"location":"autoapi/polarrouteserver/route_api/utils/#polarrouteserver.route_api.utils._closest_route_in_tolerance","text":"Takes a list of routes and returns the closest if any are within tolerance, or None. Source code in polarrouteserver/route_api/utils.py 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 def _closest_route_in_tolerance ( routes : list , start_lat : float , start_lon : float , end_lat : float , end_lon : float , tolerance_nm : float = settings . WAYPOINT_DISTANCE_TOLERANCE , ) -> Union [ Route , None ]: \"\"\"Takes a list of routes and returns the closest if any are within tolerance, or None.\"\"\" def point_within_tolerance ( point_1 : tuple , point_2 : tuple ) -> bool : return haversine_distance ( point_1 , point_2 ) < tolerance_nm def haversine_distance ( point_1 : tuple , point_2 : tuple ) -> float : return haversine . haversine ( point_1 , point_2 , unit = haversine . Unit . NAUTICAL_MILES ) routes_in_tolerance = [] for route in routes : if point_within_tolerance ( ( start_lat , start_lon ), ( route . start_lat , route . start_lon ) ) and point_within_tolerance ( ( end_lat , end_lon ), ( route . end_lat , route . end_lon ) ): routes_in_tolerance . append ( { \"id\" : route . id , } ) if len ( routes_in_tolerance ) == 0 : return None elif len ( routes_in_tolerance ) == 1 : return Route . objects . get ( id = routes_in_tolerance [ 0 ][ \"id\" ]) else : for i , route_dict in enumerate ( routes_in_tolerance ): route = Route . objects . get ( id = route_dict [ \"id\" ]) routes_in_tolerance [ i ] . update ( { \"cumulative_distance\" : haversine_distance ( ( start_lat , start_lon ), ( route . start_lat , route . start_lon ) ) + haversine_distance ( ( end_lat , end_lon ), ( route . end_lat , route . end_lon ) ) } ) from operator import itemgetter closest_route = sorted ( routes_in_tolerance , key = itemgetter ( \"cumulative_distance\" ) )[ 0 ] return Route . objects . get ( id = closest_route [ \"id\" ])","title":"_closest_route_in_tolerance"},{"location":"autoapi/polarrouteserver/route_api/utils/#polarrouteserver.route_api.utils.calculate_md5","text":"create md5sum checksum for any file Source code in polarrouteserver/route_api/utils.py 163 164 165 166 167 168 169 170 def calculate_md5 ( filename ): \"\"\"create md5sum checksum for any file\"\"\" hash_md5 = hashlib . md5 () with open ( filename , \"rb\" ) as f : for chunk in iter ( lambda : f . read ( 4096 ), b \"\" ): hash_md5 . update ( chunk ) return hash_md5 . hexdigest ()","title":"calculate_md5"},{"location":"autoapi/polarrouteserver/route_api/utils/#polarrouteserver.route_api.utils.check_mesh_data","text":"Check a mesh object for missing data sources. Parameters: mesh ( Mesh ) \u2013 mesh object to evaluate. Returns: str \u2013 A user-friendly warning message as a string. Source code in polarrouteserver/route_api/utils.py 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 def check_mesh_data ( mesh : Mesh ) -> str : \"\"\"Check a mesh object for missing data sources. Args: mesh (Mesh): mesh object to evaluate. Returns: A user-friendly warning message as a string. \"\"\" message = \"\" mesh_data_sources = mesh . json [ 'config' ][ 'mesh_info' ] . get ( 'data_sources' , None ) # check for completely absent data sources if mesh_data_sources is None : message = \"Mesh has no data sources.\" return message expected_sources = settings . EXPECTED_MESH_DATA_SOURCES expected_num_data_files = settings . EXPECTED_MESH_DATA_FILES for data_type , data_loader in expected_sources . items (): # check for missing individual data sources data_source = [ d for d in mesh_data_sources if d [ \"loader\" ] == data_loader ] if len ( data_source ) == 0 : message += f \"No { data_type } data available for this mesh. \\n \" # skip to the next data source continue # check for unexpected number of data files data_source_num_expected_files = expected_num_data_files . get ( data_loader , None ) if data_source_num_expected_files is not None : actual_num_files = len ([ f for f in data_source [ 0 ][ \"params\" ][ \"files\" ] if f != \"\" ]) # number of files removing empty strings if actual_num_files != data_source_num_expected_files : message += f \" { actual_num_files } of expected { data_source_num_expected_files } days' data available for { data_type } . \\n \" return message","title":"check_mesh_data"},{"location":"autoapi/polarrouteserver/route_api/utils/#polarrouteserver.route_api.utils.evaluate_route","text":"Run calculate_route method from PolarRoute to evaluate the fuel usage and travel time of a route. Parameters: route_json ( dict ) \u2013 route to evaluate in geojson format. mesh ( Mesh ) \u2013 mesh object on which to evaluate the route. Returns: dict ( dict ) \u2013 evaluated route Source code in polarrouteserver/route_api/utils.py 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 def evaluate_route ( route_json : dict , mesh : Mesh ) -> dict : \"\"\"Run calculate_route method from PolarRoute to evaluate the fuel usage and travel time of a route. Args: route_json (dict): route to evaluate in geojson format. mesh (polarrouteserver.models.Mesh): mesh object on which to evaluate the route. Returns: dict: evaluated route \"\"\" if route_json [ \"features\" ][ 0 ] . get ( \"properties\" , None ) is None : route_json [ \"features\" ][ 0 ][ \"properties\" ] = { \"from\" : \"Start\" , \"to\" : \"End\" } # route_calc only supports files, write out both route and mesh as temporary files route_file = NamedTemporaryFile ( delete = False , suffix = \".json\" ) with open ( route_file . name , \"w\" ) as fp : json . dump ( route_json , fp ) mesh_file = NamedTemporaryFile ( delete = False , suffix = \".json\" ) with open ( mesh_file . name , \"w\" ) as fp : json . dump ( mesh . json , fp ) try : calc_route = route_calc ( route_file . name , mesh_file . name ) except Exception as e : logger . error ( e ) return None finally : for file in ( route_file , mesh_file ): try : os . remove ( file . name ) except Exception as e : logger . warning ( f \" { file } not removed due to { e } \" ) time_days = calc_route [ \"features\" ][ 0 ][ \"properties\" ][ \"traveltime\" ][ - 1 ] time_str = convert_decimal_days ( time_days ) fuel = round ( calc_route [ \"features\" ][ 0 ][ \"properties\" ][ \"fuel\" ][ - 1 ], 2 ) return dict ( route = calc_route , time_days = time_days , time_str = time_str , fuel_tonnes = fuel )","title":"evaluate_route"},{"location":"autoapi/polarrouteserver/route_api/utils/#polarrouteserver.route_api.utils.route_exists","text":"Check if a route of given parameters has already been calculated. Works through list of meshes in order, returns first matching route Return None if not and the route object if it has. Source code in polarrouteserver/route_api/utils.py 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 def route_exists ( meshes : Union [ Mesh , list [ Mesh ]], start_lat : float , start_lon : float , end_lat : float , end_lon : float , ) -> Union [ Route , None ]: \"\"\"Check if a route of given parameters has already been calculated. Works through list of meshes in order, returns first matching route Return None if not and the route object if it has. \"\"\" if isinstance ( meshes , Mesh ): meshes = [ meshes ] for mesh in meshes : same_mesh_routes = Route . objects . filter ( mesh = mesh ) # use set to preserve uniqueness successful_route_ids = set () # remove any failed routes for route in same_mesh_routes : # job_set can't be filtered since status is a property method for job in route . job_set . all (): if job . status != \"FAILURE\" : successful_route_ids . add ( route . id ) successful_routes = same_mesh_routes . filter ( id__in = successful_route_ids ) # if there are none return None if len ( successful_routes ) == 0 : continue else : exact_routes = successful_routes . filter ( start_lat = start_lat , start_lon = start_lon , end_lat = end_lat , end_lon = end_lon , ) if len ( exact_routes ) == 1 : return exact_routes [ 0 ] elif len ( exact_routes ) > 1 : # TODO if multiple matching routes exist, which to return? return exact_routes [ 0 ] else : # if no exact routes, look for any that are close enough return _closest_route_in_tolerance ( same_mesh_routes , start_lat , start_lon , end_lat , end_lon ) return None","title":"route_exists"},{"location":"autoapi/polarrouteserver/route_api/utils/#polarrouteserver.route_api.utils.select_mesh","text":"Find the most suitable mesh from the database for a given set of start and end coordinates. Returns either a list of Mesh objects or None. Source code in polarrouteserver/route_api/utils.py 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 def select_mesh ( start_lat : float , start_lon : float , end_lat : float , end_lon : float , ) -> Union [ list [ Mesh ], None ]: \"\"\"Find the most suitable mesh from the database for a given set of start and end coordinates. Returns either a list of Mesh objects or None. \"\"\" try : # get meshes which contain both start and end points containing_meshes = Mesh . objects . filter ( lat_min__lte = start_lat , lat_max__gte = start_lat , lon_min__lte = start_lon , lon_max__gte = start_lon , ) . filter ( lat_min__lte = end_lat , lat_max__gte = end_lat , lon_min__lte = end_lon , lon_max__gte = end_lon , ) # get the date of the most recently created mesh latest_date = containing_meshes . latest ( \"created\" ) . created . date () # get all valid meshes from that creation date valid_meshes = containing_meshes . filter ( created__date = latest_date ) # return the smallest return sorted ( valid_meshes , key = lambda mesh : mesh . size ) except Mesh . DoesNotExist : return None","title":"select_mesh"},{"location":"autoapi/polarrouteserver/route_api/utils/#polarrouteserver.route_api.utils.select_mesh_for_route_evaluation","text":"Select a mesh from the database to be used for route evaluation. The latest mesh containing all points in the route will be chosen. If no suitable meshes are available, return None. Parameters: route ( dict ) \u2013 GeoJSON route to be evaluated. Returns: Union [ list [ Mesh ], None] \u2013 Union[Mesh,None]: Selected mesh object or None. Source code in polarrouteserver/route_api/utils.py 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 def select_mesh_for_route_evaluation ( route : dict ) -> Union [ list [ Mesh ], None ]: \"\"\"Select a mesh from the database to be used for route evaluation. The latest mesh containing all points in the route will be chosen. If no suitable meshes are available, return None. Args: route (dict): GeoJSON route to be evaluated. Returns: Union[Mesh,None]: Selected mesh object or None. \"\"\" coordinates = route [ \"features\" ][ 0 ][ \"geometry\" ][ \"coordinates\" ] lats = [ c [ 0 ] for c in coordinates ] lons = [ c [ 1 ] for c in coordinates ] return select_mesh ( min ( lats ), min ( lons ), max ( lats ), max ( lons ))","title":"select_mesh_for_route_evaluation"},{"location":"autoapi/polarrouteserver/route_api/views/","text":"LoggingMixin Provides full logging of requests and responses Source code in polarrouteserver/route_api/views.py 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 class LoggingMixin : \"\"\" Provides full logging of requests and responses \"\"\" def __init__ ( self , * args , ** kwargs ): super () . __init__ ( * args , ** kwargs ) self . logger = logging . getLogger ( \"django.request\" ) def initial ( self , request , * args , ** kwargs ): try : self . logger . debug ( { \"request\" : request . data , \"method\" : request . method , \"endpoint\" : request . path , \"user\" : request . user . username , \"ip_address\" : request . META . get ( \"REMOTE_ADDR\" ), \"user_agent\" : request . META . get ( \"HTTP_USER_AGENT\" ), } ) except Exception : self . logger . exception ( \"Error logging request data\" ) super () . initial ( request , * args , ** kwargs ) def finalize_response ( self , request , response , * args , ** kwargs ): try : self . logger . debug ( { \"response\" : response . data , \"status_code\" : response . status_code , \"user\" : request . user . username , \"ip_address\" : request . META . get ( \"REMOTE_ADDR\" ), \"user_agent\" : request . META . get ( \"HTTP_USER_AGENT\" ), } ) except Exception : self . logger . exception ( \"Error logging response data\" ) return super () . finalize_response ( request , response , * args , ** kwargs ) RecentRoutesView Bases: LoggingMixin , GenericAPIView Source code in polarrouteserver/route_api/views.py 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 class RecentRoutesView ( LoggingMixin , GenericAPIView ): def get ( self , request ): \"\"\"Get recent routes\"\"\" logger . info ( f \" { request . method } { request . path } from { request . META . get ( 'REMOTE_ADDR' ) } \" ) # only get today's routes routes_today = Route . objects . filter ( requested__date = datetime . now () . date ()) response_data = [] logger . debug ( f \"Found { len ( routes_today ) } routes today.\" ) for route in routes_today : logger . debug ( f \" { route . id } \" ) try : job = route . job_set . latest ( \"datetime\" ) except Job . DoesNotExist : logger . debug ( f \"Job does not exist for route { route . id } \" ) continue result = AsyncResult ( id = str ( job . id ), app = app ) status = result . state data = { \"id\" : str ( job . id ), \"status\" : status } data . update ( RouteSerializer ( route ) . data ) if status == \"FAILURE\" : data . update ({ \"error\" : route . info }) response_data . append ( data ) return Response ( response_data , headers = { \"Content-Type\" : \"application/json\" }, status = rest_framework . status . HTTP_200_OK , ) get ( request ) Get recent routes Source code in polarrouteserver/route_api/views.py 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 def get ( self , request ): \"\"\"Get recent routes\"\"\" logger . info ( f \" { request . method } { request . path } from { request . META . get ( 'REMOTE_ADDR' ) } \" ) # only get today's routes routes_today = Route . objects . filter ( requested__date = datetime . now () . date ()) response_data = [] logger . debug ( f \"Found { len ( routes_today ) } routes today.\" ) for route in routes_today : logger . debug ( f \" { route . id } \" ) try : job = route . job_set . latest ( \"datetime\" ) except Job . DoesNotExist : logger . debug ( f \"Job does not exist for route { route . id } \" ) continue result = AsyncResult ( id = str ( job . id ), app = app ) status = result . state data = { \"id\" : str ( job . id ), \"status\" : status } data . update ( RouteSerializer ( route ) . data ) if status == \"FAILURE\" : data . update ({ \"error\" : route . info }) response_data . append ( data ) return Response ( response_data , headers = { \"Content-Type\" : \"application/json\" }, status = rest_framework . status . HTTP_200_OK , ) RouteView Bases: LoggingMixin , GenericAPIView Source code in polarrouteserver/route_api/views.py 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 class RouteView ( LoggingMixin , GenericAPIView ): serializer_class = RouteSerializer def post ( self , request ): \"\"\"Entry point for route requests\"\"\" logger . info ( f \" { request . method } { request . path } from { request . META . get ( 'REMOTE_ADDR' ) } : { request . data } \" ) data = request . data # TODO validate request JSON start_lat = data [ \"start_lat\" ] start_lon = data [ \"start_lon\" ] end_lat = data [ \"end_lat\" ] end_lon = data [ \"end_lon\" ] start_name = data . get ( \"start_name\" , None ) end_name = data . get ( \"end_name\" , None ) custom_mesh_id = data . get ( \"mesh_id\" , None ) force_recalculate = data . get ( \"force_recalculate\" , False ) if custom_mesh_id : try : logger . info ( f \"Got custom mesh id { custom_mesh_id } in request.\" ) meshes = [ Mesh . objects . get ( id = custom_mesh_id )] except Mesh . DoesNotExist : msg = f \"Mesh id { custom_mesh_id } requested. Does not exist.\" logger . info ( msg ) return Response ( data = { \"info\" : { \"error\" : msg }, \"status\" : \"FAILURE\" , }, headers = { \"Content-Type\" : \"application/json\" }, status = rest_framework . status . HTTP_202_ACCEPTED , ) else : meshes = select_mesh ( start_lat , start_lon , end_lat , end_lon ) if meshes is None : return Response ( data = { \"info\" : { \"error\" : \"No suitable mesh available.\" }, \"status\" : \"FAILURE\" , }, headers = { \"Content-Type\" : \"application/json\" }, status = rest_framework . status . HTTP_200_OK , ) logger . debug ( f \"Using meshes: { [ mesh . id for mesh in meshes ] } \" ) # TODO Future: calculate an up to date mesh if none available existing_route = route_exists ( meshes , start_lat , start_lon , end_lat , end_lon ) if existing_route is not None : if not force_recalculate : logger . info ( f \"Existing route found: { existing_route } \" ) response_data = RouteSerializer ( existing_route ) . data if existing_route . job_set . count () > 0 : existing_job = existing_route . job_set . latest ( \"datetime\" ) response_data . update ( { \"info\" : { \"info\" : \"Pre-existing route found and returned. To force new calculation, include 'force_recalculate': true in POST request.\" }, \"id\" : str ( existing_job . id ), \"status-url\" : reverse ( \"route\" , args = [ existing_job . id ], request = request ), } ) else : response_data . update ( { \"info\" : { \"error\" : \"Pre-existing route was found but there was an error. \\ To force new calculation, include 'force_recalculate': true in POST request.\" } } ) return Response ( data = response_data , headers = { \"Content-Type\" : \"application/json\" }, status = rest_framework . status . HTTP_202_ACCEPTED , ) else : logger . info ( f \"Found existing route(s) but got force_recalculate= { force_recalculate } , beginning recalculation.\" ) logger . debug ( f \"Using mesh { meshes [ 0 ] . id } as primary mesh with { [ mesh . id for mesh in meshes [ 1 :]] } as backup.\" ) # Create route in database route = Route . objects . create ( start_lat = start_lat , start_lon = start_lon , end_lat = end_lat , end_lon = end_lon , mesh = meshes [ 0 ], start_name = start_name , end_name = end_name , ) # Start the task calculation task = optimise_route . delay ( route . id , backup_mesh_ids = [ mesh . id for mesh in meshes [ 1 :]] ) # Create database record representing the calculation job job = Job . objects . create ( id = task . id , route = route , ) # Prepare response data data = { \"id\" : job . id , # url to request status of requested route \"status-url\" : reverse ( \"route\" , args = [ job . id ], request = request ), } return Response ( data , headers = { \"Content-Type\" : \"application/json\" }, status = rest_framework . status . HTTP_202_ACCEPTED , ) def get ( self , request , id ): \"Return status of route calculation and route itself if complete.\" logger . info ( f \" { request . method } { request . path } from { request . META . get ( 'REMOTE_ADDR' ) } \" ) # update job with latest state job = Job . objects . get ( id = id ) # status = job.status result = AsyncResult ( id = str ( id ), app = app ) status = result . state data = { \"id\" : str ( id ), \"status\" : status } data . update ( RouteSerializer ( job . route ) . data ) if status == \"FAILURE\" : data . update ({ \"error\" : job . route . info }) return Response ( data , headers = { \"Content-Type\" : \"application/json\" }, status = rest_framework . status . HTTP_200_OK , ) def delete ( self , request , id ): \"\"\"Cancel route calculation\"\"\" logger . info ( f \" { request . method } { request . path } from { request . META . get ( 'REMOTE_ADDR' ) } \" ) result = AsyncResult ( id = str ( id ), app = app ) result . revoke () return Response ( {}, headers = { \"Content-Type\" : \"application/json\" }, status = rest_framework . status . HTTP_202_ACCEPTED , ) delete ( request , id ) Cancel route calculation Source code in polarrouteserver/route_api/views.py 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 def delete ( self , request , id ): \"\"\"Cancel route calculation\"\"\" logger . info ( f \" { request . method } { request . path } from { request . META . get ( 'REMOTE_ADDR' ) } \" ) result = AsyncResult ( id = str ( id ), app = app ) result . revoke () return Response ( {}, headers = { \"Content-Type\" : \"application/json\" }, status = rest_framework . status . HTTP_202_ACCEPTED , ) get ( request , id ) Return status of route calculation and route itself if complete. Source code in polarrouteserver/route_api/views.py 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 def get ( self , request , id ): \"Return status of route calculation and route itself if complete.\" logger . info ( f \" { request . method } { request . path } from { request . META . get ( 'REMOTE_ADDR' ) } \" ) # update job with latest state job = Job . objects . get ( id = id ) # status = job.status result = AsyncResult ( id = str ( id ), app = app ) status = result . state data = { \"id\" : str ( id ), \"status\" : status } data . update ( RouteSerializer ( job . route ) . data ) if status == \"FAILURE\" : data . update ({ \"error\" : job . route . info }) return Response ( data , headers = { \"Content-Type\" : \"application/json\" }, status = rest_framework . status . HTTP_200_OK , ) post ( request ) Entry point for route requests Source code in polarrouteserver/route_api/views.py 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 def post ( self , request ): \"\"\"Entry point for route requests\"\"\" logger . info ( f \" { request . method } { request . path } from { request . META . get ( 'REMOTE_ADDR' ) } : { request . data } \" ) data = request . data # TODO validate request JSON start_lat = data [ \"start_lat\" ] start_lon = data [ \"start_lon\" ] end_lat = data [ \"end_lat\" ] end_lon = data [ \"end_lon\" ] start_name = data . get ( \"start_name\" , None ) end_name = data . get ( \"end_name\" , None ) custom_mesh_id = data . get ( \"mesh_id\" , None ) force_recalculate = data . get ( \"force_recalculate\" , False ) if custom_mesh_id : try : logger . info ( f \"Got custom mesh id { custom_mesh_id } in request.\" ) meshes = [ Mesh . objects . get ( id = custom_mesh_id )] except Mesh . DoesNotExist : msg = f \"Mesh id { custom_mesh_id } requested. Does not exist.\" logger . info ( msg ) return Response ( data = { \"info\" : { \"error\" : msg }, \"status\" : \"FAILURE\" , }, headers = { \"Content-Type\" : \"application/json\" }, status = rest_framework . status . HTTP_202_ACCEPTED , ) else : meshes = select_mesh ( start_lat , start_lon , end_lat , end_lon ) if meshes is None : return Response ( data = { \"info\" : { \"error\" : \"No suitable mesh available.\" }, \"status\" : \"FAILURE\" , }, headers = { \"Content-Type\" : \"application/json\" }, status = rest_framework . status . HTTP_200_OK , ) logger . debug ( f \"Using meshes: { [ mesh . id for mesh in meshes ] } \" ) # TODO Future: calculate an up to date mesh if none available existing_route = route_exists ( meshes , start_lat , start_lon , end_lat , end_lon ) if existing_route is not None : if not force_recalculate : logger . info ( f \"Existing route found: { existing_route } \" ) response_data = RouteSerializer ( existing_route ) . data if existing_route . job_set . count () > 0 : existing_job = existing_route . job_set . latest ( \"datetime\" ) response_data . update ( { \"info\" : { \"info\" : \"Pre-existing route found and returned. To force new calculation, include 'force_recalculate': true in POST request.\" }, \"id\" : str ( existing_job . id ), \"status-url\" : reverse ( \"route\" , args = [ existing_job . id ], request = request ), } ) else : response_data . update ( { \"info\" : { \"error\" : \"Pre-existing route was found but there was an error. \\ To force new calculation, include 'force_recalculate': true in POST request.\" } } ) return Response ( data = response_data , headers = { \"Content-Type\" : \"application/json\" }, status = rest_framework . status . HTTP_202_ACCEPTED , ) else : logger . info ( f \"Found existing route(s) but got force_recalculate= { force_recalculate } , beginning recalculation.\" ) logger . debug ( f \"Using mesh { meshes [ 0 ] . id } as primary mesh with { [ mesh . id for mesh in meshes [ 1 :]] } as backup.\" ) # Create route in database route = Route . objects . create ( start_lat = start_lat , start_lon = start_lon , end_lat = end_lat , end_lon = end_lon , mesh = meshes [ 0 ], start_name = start_name , end_name = end_name , ) # Start the task calculation task = optimise_route . delay ( route . id , backup_mesh_ids = [ mesh . id for mesh in meshes [ 1 :]] ) # Create database record representing the calculation job job = Job . objects . create ( id = task . id , route = route , ) # Prepare response data data = { \"id\" : job . id , # url to request status of requested route \"status-url\" : reverse ( \"route\" , args = [ job . id ], request = request ), } return Response ( data , headers = { \"Content-Type\" : \"application/json\" }, status = rest_framework . status . HTTP_202_ACCEPTED , )","title":"views"},{"location":"autoapi/polarrouteserver/route_api/views/#polarrouteserver.route_api.views.LoggingMixin","text":"Provides full logging of requests and responses Source code in polarrouteserver/route_api/views.py 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 class LoggingMixin : \"\"\" Provides full logging of requests and responses \"\"\" def __init__ ( self , * args , ** kwargs ): super () . __init__ ( * args , ** kwargs ) self . logger = logging . getLogger ( \"django.request\" ) def initial ( self , request , * args , ** kwargs ): try : self . logger . debug ( { \"request\" : request . data , \"method\" : request . method , \"endpoint\" : request . path , \"user\" : request . user . username , \"ip_address\" : request . META . get ( \"REMOTE_ADDR\" ), \"user_agent\" : request . META . get ( \"HTTP_USER_AGENT\" ), } ) except Exception : self . logger . exception ( \"Error logging request data\" ) super () . initial ( request , * args , ** kwargs ) def finalize_response ( self , request , response , * args , ** kwargs ): try : self . logger . debug ( { \"response\" : response . data , \"status_code\" : response . status_code , \"user\" : request . user . username , \"ip_address\" : request . META . get ( \"REMOTE_ADDR\" ), \"user_agent\" : request . META . get ( \"HTTP_USER_AGENT\" ), } ) except Exception : self . logger . exception ( \"Error logging response data\" ) return super () . finalize_response ( request , response , * args , ** kwargs )","title":"LoggingMixin"},{"location":"autoapi/polarrouteserver/route_api/views/#polarrouteserver.route_api.views.RecentRoutesView","text":"Bases: LoggingMixin , GenericAPIView Source code in polarrouteserver/route_api/views.py 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 class RecentRoutesView ( LoggingMixin , GenericAPIView ): def get ( self , request ): \"\"\"Get recent routes\"\"\" logger . info ( f \" { request . method } { request . path } from { request . META . get ( 'REMOTE_ADDR' ) } \" ) # only get today's routes routes_today = Route . objects . filter ( requested__date = datetime . now () . date ()) response_data = [] logger . debug ( f \"Found { len ( routes_today ) } routes today.\" ) for route in routes_today : logger . debug ( f \" { route . id } \" ) try : job = route . job_set . latest ( \"datetime\" ) except Job . DoesNotExist : logger . debug ( f \"Job does not exist for route { route . id } \" ) continue result = AsyncResult ( id = str ( job . id ), app = app ) status = result . state data = { \"id\" : str ( job . id ), \"status\" : status } data . update ( RouteSerializer ( route ) . data ) if status == \"FAILURE\" : data . update ({ \"error\" : route . info }) response_data . append ( data ) return Response ( response_data , headers = { \"Content-Type\" : \"application/json\" }, status = rest_framework . status . HTTP_200_OK , )","title":"RecentRoutesView"},{"location":"autoapi/polarrouteserver/route_api/views/#polarrouteserver.route_api.views.RecentRoutesView.get","text":"Get recent routes Source code in polarrouteserver/route_api/views.py 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 def get ( self , request ): \"\"\"Get recent routes\"\"\" logger . info ( f \" { request . method } { request . path } from { request . META . get ( 'REMOTE_ADDR' ) } \" ) # only get today's routes routes_today = Route . objects . filter ( requested__date = datetime . now () . date ()) response_data = [] logger . debug ( f \"Found { len ( routes_today ) } routes today.\" ) for route in routes_today : logger . debug ( f \" { route . id } \" ) try : job = route . job_set . latest ( \"datetime\" ) except Job . DoesNotExist : logger . debug ( f \"Job does not exist for route { route . id } \" ) continue result = AsyncResult ( id = str ( job . id ), app = app ) status = result . state data = { \"id\" : str ( job . id ), \"status\" : status } data . update ( RouteSerializer ( route ) . data ) if status == \"FAILURE\" : data . update ({ \"error\" : route . info }) response_data . append ( data ) return Response ( response_data , headers = { \"Content-Type\" : \"application/json\" }, status = rest_framework . status . HTTP_200_OK , )","title":"get"},{"location":"autoapi/polarrouteserver/route_api/views/#polarrouteserver.route_api.views.RouteView","text":"Bases: LoggingMixin , GenericAPIView Source code in polarrouteserver/route_api/views.py 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 class RouteView ( LoggingMixin , GenericAPIView ): serializer_class = RouteSerializer def post ( self , request ): \"\"\"Entry point for route requests\"\"\" logger . info ( f \" { request . method } { request . path } from { request . META . get ( 'REMOTE_ADDR' ) } : { request . data } \" ) data = request . data # TODO validate request JSON start_lat = data [ \"start_lat\" ] start_lon = data [ \"start_lon\" ] end_lat = data [ \"end_lat\" ] end_lon = data [ \"end_lon\" ] start_name = data . get ( \"start_name\" , None ) end_name = data . get ( \"end_name\" , None ) custom_mesh_id = data . get ( \"mesh_id\" , None ) force_recalculate = data . get ( \"force_recalculate\" , False ) if custom_mesh_id : try : logger . info ( f \"Got custom mesh id { custom_mesh_id } in request.\" ) meshes = [ Mesh . objects . get ( id = custom_mesh_id )] except Mesh . DoesNotExist : msg = f \"Mesh id { custom_mesh_id } requested. Does not exist.\" logger . info ( msg ) return Response ( data = { \"info\" : { \"error\" : msg }, \"status\" : \"FAILURE\" , }, headers = { \"Content-Type\" : \"application/json\" }, status = rest_framework . status . HTTP_202_ACCEPTED , ) else : meshes = select_mesh ( start_lat , start_lon , end_lat , end_lon ) if meshes is None : return Response ( data = { \"info\" : { \"error\" : \"No suitable mesh available.\" }, \"status\" : \"FAILURE\" , }, headers = { \"Content-Type\" : \"application/json\" }, status = rest_framework . status . HTTP_200_OK , ) logger . debug ( f \"Using meshes: { [ mesh . id for mesh in meshes ] } \" ) # TODO Future: calculate an up to date mesh if none available existing_route = route_exists ( meshes , start_lat , start_lon , end_lat , end_lon ) if existing_route is not None : if not force_recalculate : logger . info ( f \"Existing route found: { existing_route } \" ) response_data = RouteSerializer ( existing_route ) . data if existing_route . job_set . count () > 0 : existing_job = existing_route . job_set . latest ( \"datetime\" ) response_data . update ( { \"info\" : { \"info\" : \"Pre-existing route found and returned. To force new calculation, include 'force_recalculate': true in POST request.\" }, \"id\" : str ( existing_job . id ), \"status-url\" : reverse ( \"route\" , args = [ existing_job . id ], request = request ), } ) else : response_data . update ( { \"info\" : { \"error\" : \"Pre-existing route was found but there was an error. \\ To force new calculation, include 'force_recalculate': true in POST request.\" } } ) return Response ( data = response_data , headers = { \"Content-Type\" : \"application/json\" }, status = rest_framework . status . HTTP_202_ACCEPTED , ) else : logger . info ( f \"Found existing route(s) but got force_recalculate= { force_recalculate } , beginning recalculation.\" ) logger . debug ( f \"Using mesh { meshes [ 0 ] . id } as primary mesh with { [ mesh . id for mesh in meshes [ 1 :]] } as backup.\" ) # Create route in database route = Route . objects . create ( start_lat = start_lat , start_lon = start_lon , end_lat = end_lat , end_lon = end_lon , mesh = meshes [ 0 ], start_name = start_name , end_name = end_name , ) # Start the task calculation task = optimise_route . delay ( route . id , backup_mesh_ids = [ mesh . id for mesh in meshes [ 1 :]] ) # Create database record representing the calculation job job = Job . objects . create ( id = task . id , route = route , ) # Prepare response data data = { \"id\" : job . id , # url to request status of requested route \"status-url\" : reverse ( \"route\" , args = [ job . id ], request = request ), } return Response ( data , headers = { \"Content-Type\" : \"application/json\" }, status = rest_framework . status . HTTP_202_ACCEPTED , ) def get ( self , request , id ): \"Return status of route calculation and route itself if complete.\" logger . info ( f \" { request . method } { request . path } from { request . META . get ( 'REMOTE_ADDR' ) } \" ) # update job with latest state job = Job . objects . get ( id = id ) # status = job.status result = AsyncResult ( id = str ( id ), app = app ) status = result . state data = { \"id\" : str ( id ), \"status\" : status } data . update ( RouteSerializer ( job . route ) . data ) if status == \"FAILURE\" : data . update ({ \"error\" : job . route . info }) return Response ( data , headers = { \"Content-Type\" : \"application/json\" }, status = rest_framework . status . HTTP_200_OK , ) def delete ( self , request , id ): \"\"\"Cancel route calculation\"\"\" logger . info ( f \" { request . method } { request . path } from { request . META . get ( 'REMOTE_ADDR' ) } \" ) result = AsyncResult ( id = str ( id ), app = app ) result . revoke () return Response ( {}, headers = { \"Content-Type\" : \"application/json\" }, status = rest_framework . status . HTTP_202_ACCEPTED , )","title":"RouteView"},{"location":"autoapi/polarrouteserver/route_api/views/#polarrouteserver.route_api.views.RouteView.delete","text":"Cancel route calculation Source code in polarrouteserver/route_api/views.py 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 def delete ( self , request , id ): \"\"\"Cancel route calculation\"\"\" logger . info ( f \" { request . method } { request . path } from { request . META . get ( 'REMOTE_ADDR' ) } \" ) result = AsyncResult ( id = str ( id ), app = app ) result . revoke () return Response ( {}, headers = { \"Content-Type\" : \"application/json\" }, status = rest_framework . status . HTTP_202_ACCEPTED , )","title":"delete"},{"location":"autoapi/polarrouteserver/route_api/views/#polarrouteserver.route_api.views.RouteView.get","text":"Return status of route calculation and route itself if complete. Source code in polarrouteserver/route_api/views.py 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 def get ( self , request , id ): \"Return status of route calculation and route itself if complete.\" logger . info ( f \" { request . method } { request . path } from { request . META . get ( 'REMOTE_ADDR' ) } \" ) # update job with latest state job = Job . objects . get ( id = id ) # status = job.status result = AsyncResult ( id = str ( id ), app = app ) status = result . state data = { \"id\" : str ( id ), \"status\" : status } data . update ( RouteSerializer ( job . route ) . data ) if status == \"FAILURE\" : data . update ({ \"error\" : job . route . info }) return Response ( data , headers = { \"Content-Type\" : \"application/json\" }, status = rest_framework . status . HTTP_200_OK , )","title":"get"},{"location":"autoapi/polarrouteserver/route_api/views/#polarrouteserver.route_api.views.RouteView.post","text":"Entry point for route requests Source code in polarrouteserver/route_api/views.py 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 def post ( self , request ): \"\"\"Entry point for route requests\"\"\" logger . info ( f \" { request . method } { request . path } from { request . META . get ( 'REMOTE_ADDR' ) } : { request . data } \" ) data = request . data # TODO validate request JSON start_lat = data [ \"start_lat\" ] start_lon = data [ \"start_lon\" ] end_lat = data [ \"end_lat\" ] end_lon = data [ \"end_lon\" ] start_name = data . get ( \"start_name\" , None ) end_name = data . get ( \"end_name\" , None ) custom_mesh_id = data . get ( \"mesh_id\" , None ) force_recalculate = data . get ( \"force_recalculate\" , False ) if custom_mesh_id : try : logger . info ( f \"Got custom mesh id { custom_mesh_id } in request.\" ) meshes = [ Mesh . objects . get ( id = custom_mesh_id )] except Mesh . DoesNotExist : msg = f \"Mesh id { custom_mesh_id } requested. Does not exist.\" logger . info ( msg ) return Response ( data = { \"info\" : { \"error\" : msg }, \"status\" : \"FAILURE\" , }, headers = { \"Content-Type\" : \"application/json\" }, status = rest_framework . status . HTTP_202_ACCEPTED , ) else : meshes = select_mesh ( start_lat , start_lon , end_lat , end_lon ) if meshes is None : return Response ( data = { \"info\" : { \"error\" : \"No suitable mesh available.\" }, \"status\" : \"FAILURE\" , }, headers = { \"Content-Type\" : \"application/json\" }, status = rest_framework . status . HTTP_200_OK , ) logger . debug ( f \"Using meshes: { [ mesh . id for mesh in meshes ] } \" ) # TODO Future: calculate an up to date mesh if none available existing_route = route_exists ( meshes , start_lat , start_lon , end_lat , end_lon ) if existing_route is not None : if not force_recalculate : logger . info ( f \"Existing route found: { existing_route } \" ) response_data = RouteSerializer ( existing_route ) . data if existing_route . job_set . count () > 0 : existing_job = existing_route . job_set . latest ( \"datetime\" ) response_data . update ( { \"info\" : { \"info\" : \"Pre-existing route found and returned. To force new calculation, include 'force_recalculate': true in POST request.\" }, \"id\" : str ( existing_job . id ), \"status-url\" : reverse ( \"route\" , args = [ existing_job . id ], request = request ), } ) else : response_data . update ( { \"info\" : { \"error\" : \"Pre-existing route was found but there was an error. \\ To force new calculation, include 'force_recalculate': true in POST request.\" } } ) return Response ( data = response_data , headers = { \"Content-Type\" : \"application/json\" }, status = rest_framework . status . HTTP_202_ACCEPTED , ) else : logger . info ( f \"Found existing route(s) but got force_recalculate= { force_recalculate } , beginning recalculation.\" ) logger . debug ( f \"Using mesh { meshes [ 0 ] . id } as primary mesh with { [ mesh . id for mesh in meshes [ 1 :]] } as backup.\" ) # Create route in database route = Route . objects . create ( start_lat = start_lat , start_lon = start_lon , end_lat = end_lat , end_lon = end_lon , mesh = meshes [ 0 ], start_name = start_name , end_name = end_name , ) # Start the task calculation task = optimise_route . delay ( route . id , backup_mesh_ids = [ mesh . id for mesh in meshes [ 1 :]] ) # Create database record representing the calculation job job = Job . objects . create ( id = task . id , route = route , ) # Prepare response data data = { \"id\" : job . id , # url to request status of requested route \"status-url\" : reverse ( \"route\" , args = [ job . id ], request = request ), } return Response ( data , headers = { \"Content-Type\" : \"application/json\" }, status = rest_framework . status . HTTP_202_ACCEPTED , )","title":"post"}]}